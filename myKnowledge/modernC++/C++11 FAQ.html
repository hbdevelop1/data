<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>
C++11 FAQ
</title>
</head>
<body bgcolor="FFFBFB">
<center>
<a href="http://www.morganstanley.com/">Morgan Stanley</a>
|
<a href="http://www.cs.columbia.edu/">Columbia University</a>
|
<a href="http://www.cse.tamu.edu/">Texas A&amp;M University</a>


</center>
<p>
</p><center>
<a href="http://www.stroustrup.com/index.html">home</a>
|
<a href="http://www.stroustrup.com/C++.html">C++</a>
|
<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>
|
<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>
|
<a href="http://www.stroustrup.com/C++11FAQ.html">C++11 FAQ</a>
|
<a href="http://www.stroustrup.com/papers.html">publications</a>
|
<a href="http://www.stroustrup.com/4th.html">TC++PL</a>
|
<a href="http://www.stroustrup.com/Tour.html">Tour++</a>
|
<a href="http://www.stroustrup.com/programming.html">Programming</a>
|
<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>
|
<a href="http://www.stroustrup.com/bio.html">bio</a>
|
<a href="http://www.stroustrup.com/interviews.html">interviews</a>
|
<a href="http://www.stroustrup.com/applications.html">applications</a>
|
<a href="http://www.stroustrup.com/glossary.html">glossary</a>
|
<a href="http://www.stroustrup.com/compilers.html">compilers</a>
</center>
<center>
<h1><b>C++11 - the new ISO C++ standard</b></h1>
</center>

<p align="right">
Modified September 9, 2015

</p><p>
This document is written by and maintained by
<a href="http://www.stroustrup.com/index.html">Bjarne Stroustrup</a>.
Constructive comments, corrections, references, and suggestions are of course most welcome.
Currently, I'm working to improve completeness and clean up the references.
</p><p>
Translations:
</p><ul>
<li><a href="http://sergeyteplyakov.blogspot.com/2012/05/c-11-faq.html">Russian</a>.
</li><li><a href="http://chenlq.net/cpp11-faq-chs">Chinese</a>.
</li><li><a href="http://www32.ocn.ne.jp/%7Eons/text/CPP0xFAQ.html.ja">Japanese</a>.
</li><li>
<a href="http://pl.pusan.ac.kr/%7Ewoogyun/cpp11/C++11FAQ_ko.html">Korean</a>
</li></ul>
<p>
I have contributed to the new, unified,
<a href="http://isocpp.org/faq">isocpp.org C++ FAQ</a>
maintained by
<a href="http://isocpp.org/about">The C++ Foundation</a>
of which I am a director.
The maintenance of this FAQ is likely to become increasingly sporatic.
</p><p>
C++11 is the ISO C++ standard ratified in 2011.
The previous standard is often referred to as
<a href="ftp://ftp.research.att.com/pub/c++std/WP/CD2">C++98 or C++03</a>;
the differences between C++98 and C++03 are so few and so technical that they ought not concern users.
</p><p>
A late
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">working paper</a>
is available.
This is close to the final draft international standard
formally accepted by a 21-0 national vote in August 2011.
</p><p>
Before its official ratification, we called the upcoming standard C++0x.
I have not had the time to update the name consistently,
sorry, and anyway I like the name C++0x :-).
The name "C++0x" is a relict of the days where I and others, hoped for a C++08 or C++09.
Think of 'x' as hexadecimal (i.e., C++0B == C++11).
</p><p>
All official documents relating to C++11/C++0x can be found at the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/">ISO C++ committee's website</a>.
The official name of the committee is SC22 WG21.
</p><p>
Caveat: This FAQ will be under construction for quite a while.
Comments, questions, references, corrections, and suggestions welcome.


</p><p>
</p><hr>
<h2>Purpose</h2>
The purpose of this C++11 FAQ is
<ul>
<li>To give an overview of the new facilities (language features and standard libraries)
offered by C++11 in addition to what is provided by the previous version of the ISO C++ standard.
</li><li>To give an idea of the aims of the ISO C++ standards effort.
</li><li>To present a user's view of the new facilities
</li><li>To provide references to allow for a more in depth study of features.
</li><li>To name many of the individuals who contributed
(mostly as authors of the reports they wrote for the committee).
The standard is not written by a faceless organization.
</li></ul>
Please note that the purpose of this FAQ is not to provide comprehensive discussion of
individual features or a detailed explanation of how to use them.
The aim is to give simple examples to demonstrate what C++11 has to offer (plus references).
My ideal is "max one page per feature" independently of how complex a feature is.
Details can often be found in the references.


<p>
</p><hr>
<h2>Lists of questions</h2>
<p>
Here are some high-level questions
</p><ul>
<li><a href="#think">What do <i>you</i> think of C++11?</a>
</li><li><a href="#when-standard">When will C++0x be a formal standard?</a>
</li><li><a href="#when-compilers">When will compilers implement C++11?</a>
</li><li><a href="#when-libraries">When will the new standard libraries be available?</a>
</li><li><a href="#what-features">What new language features does C++11 provide?</a> (a list);
	see also <a href="#language">the questions below</a>
</li><li><a href="#what-libraries">What new standard libraries does C++11 provide?</a> (a list);
	see also <a href="#library">the questions below</a>
</li><li><a href="#aims">What were the aims of the C++0x effort?</a>
</li><li><a href="#specific-aims">What specific design aims guided the committee?</a>
</li><li><a href="#WG21">Where can I find the committee papers?</a>
</li><li><a href="#technical-papers">Where can I find academic and technical papers about C++11?</a> (a list)
</li><li><a href="#reading">Where else can I read about C++11?</a> (a list)
</li><li><a href="#videos">Are there any videos about C++11?</a> (a list)
</li><li><a href="#learn">Is C++11 hard to learn?</a>
</li><li><a href="#committee-operate">How does the committee operate?</a>
</li><li><a href="#committee-who">Who is on the committee?</a>
</li><li><a href="#1x">Will there be a C++1y?</a>
</li><li><a href="#what-concepts">What happened to "concepts?</a>
</li><li><a href="#bad-features">Are there any features you don't like?</a>
</li></ul>


<p id="language">
Questions about individual language features can be found here:
</p><ul>
<li><a href="#11">__cplusplus</a>
</li><li><a href="#align">alignments</a>
</li><li><a href="#attributes">attributes</a>
</li><li><a href="#std-atomics">atomic operations</a></li><li><a href="#auto">auto</a> (type deduction from initializer)
</li><li><a href="#C99">C99 features</a></li><li><a href="#enum">enum class</a> (scoped and strongly typed enums)
</li><li><a href="#attributes"><b>[[carries_dependency]]</b></a>
</li><li><a href="#rethrow">copying and rethrowing exceptions</a>
</li><li><a href="#constexpr">constant expressions</a> (generalized and guaranteed;<b>constexpr</b>)
</li><li><a href="#decltype">decltype</a>
</li><li><a href="#default">control of defaults: <b>default</b> and <b>delete</b></a>
</li><li><a href="#default2">control of defaults: move and copy</a>
</li><li><a href="#delegating-ctor">delegating constructors</a>
</li><li><a href="#dynamic-init">Dynamic Initialization and Destruction with Concurrency</a>
</li><li><a href="#noexcept">exception propagation</a> (preventing it; <b>noexcept</b>)
</li><li><a href="#explicit-convertion">explicit conversion operators</a>
</li><li><a href="#extended-int">extended integer types</a>
</li><li><a href="#extern-templates">extern templates</a>
</li><li><a href="#for">for statement</a>; see range-for statement
</li><li><a href="#suffix-return">suffix return type syntax</a> (extended function declaration syntax)
</li><li><a href="#member-init">in-class member initializers</a>
</li><li><a href="#inheriting">inherited constructors</a>
</li><li><a href="#init-list">initializer lists</a> (uniform and general initialization)
</li><li><a href="#inline-namespace">Inline namespace</a>
</li><li><a href="#lambda">lambdas</a>
</li><li><a href="#local-types">local classes as template arguments</a>
</li><li><a href="#long-long">long long integers</a> (at least 64 bits)
</li><li><a href="#memory-model">memory model</a>
</li><li><a href="#rval">move semantics; see rvalue references</a>
</li><li><a href="#narrowing">narrowing</a> (how to prevent it)
</li><li><a href="#attributes"><b>[[noreturn]]</b></a>
</li><li><a href="#nullptr">null pointer</a> (<b>nullptr</b>)
</li><li><a href="#override">override controls: <b>override</b></a>
</li><li><a href="#final">override controls: <b>final</b></a> 
</li><li><a href="#PODs">PODs</a> (generalized)
</li><li><a href="#for">range-for statement</a>
</li><li><a href="#raw-strings">raw string literals</a>
</li><li><a href="#brackets">right-angle brackets</a>
</li><li><a href="#rval">rvalue references</a>
</li><li><a href="#SFINAE">Simple SFINAE rule</a>
</li><li><a href="#static_assert">static (compile-time) assertions</a> (<b>static_assert</b>)
</li><li><a href="#template-alias">template alias</a>
</li><li><a href="#template-alias">template typedef</a>; see template alias
</li><li><a href="#thread-local">thread-local storage</a> (<b>thread_local</b>)
</li><li><a href="#unicode">unicode characters</a>
</li><li><a href="#uniform-init">Uniform initialization syntax and semantics</a>
</li><li><a href="#unions">unions</a> (generalized)
</li><li><a href="#UD-literals">user-defined literals</a>
</li><li><a href="#variadic-templates">variadic templates</a>
</li></ul>
I often borrow examples from the proposals.
In those cases: Thanks to the proposal authors.
Many of the examples are borrowed from my own talks and papers.

<p id="library">
Questions
about individual standard library facilities can be found here:
</p><ul>
<li><a href="#abandoning">abandoning a process</a> 
</li><li>Improvements to <a href="#algorithms">algorithms</a>
</li><li><a href="#std-array">array</a>
</li><li><a href="#std-async">async()</a>
</li><li><a href="#std-atomics">atomic operations</a>
</li><li><a href="#std-condition">Condition variables</a>
</li><li>Improvements to <a href="#containers">containers</a>
</li><li><a href="#std-function">function and bind</a>
</li><li><a href="#std-forward_list">forward_list</a> a singly-liked list
</li><li><a href="#std-future">future and promise</a>
</li><li><a href="#gc-abi">garbage collection ABI</a>
</li><li><a href="#std-unordered">hash_tables</a>; see unordered_map
</li><li><a href="#type_traits">metaprogramming and type traits</a>
</li><li><a href="#std-mutex">Mutual exclusion</a>
</li><li><a href="#std-random">random number generators</a> 
</li><li><a href="#std-regex">regex</a> a regular expression library
</li><li><a href="#scoped-allocator">scoped allocators</a> 
</li><li><a href="#std-shared_ptr">shared_ptr</a>
</li><li><a href="#std-unique_ptr">smart pointers</a>; see shared_ptr, weak_ptr, and unique_ptr
</li><li><a href="#std-threads">threads</a>
</li><li><a href="#std-duration">Time utilities</a>
</li><li><a href="#std-tuple">tuple</a>
</li><li><a href="#std-unique_ptr">unique_ptr</a>
</li><li><a href="#std-unordered">unordered_map</a>
</li><li><a href="#std-weak_ptr">weak_ptr</a>
</li><li><a href="#system-error">system error</a>
</li></ul>

<p>
Below are answers to specific questions as indexed above.




</p><p>
</p><hr>
<h2 id="think">What do <i>you</i> think of C++11?</h2>
That's a (to me) amazingly frequent question.
It may be the most frequently asked question.
Surprisingly, C++11 feels like a new language:
The pieces just fit together better than they used to and I find a higher-level style of programming more natural
than before and as efficient as ever. 
If you timidly approach C++ as just a better C or as an object-oriented language, you are going to miss the point.
The abstractions are simply more flexible and affordable than before.
Rely on the old mantra:
If you think of <i>it</i> as a separate idea or object, represent it directly in the program;
model real-world objects, and abstractions directly in code.
It's easier now:
Your ideas will map to
<a href="#enum">enumerations</a>,
objects,
classes (e.g. <a href="#default">control of defaults</a>),
class hierarchies (e.g. <a href="#inheriting">inherited constructors</a>),
templates,
<a href="#template-alias">aliases</a>,
exceptions,
<a href="#for">loops</a>,
<a href="#std-threads">threads</a>,
etc., rather than to a single "one size fits all" abstraction mechanism.
<p>
My ideal is to use programming language facilities to help programmers think differently about system design and implementation.
I think C++11 can do that - and do it not just for C++ programmers but for programmers used to a variety of modern
programming languages in the general and very broad area of systems programming.
</p><p>
In other words, I'm still an optimist.


</p><p>
</p><hr>
<h2 id="when-standard">When will C++11 be a formal standard?</h2>
It is now!
The first draft for formal comments was produced in September 2008.
The Final International Draft standard (FCD) unanimously approved by the ISO C++ committee on March 25, 2011.
It was formally approved by a 21-0 national vote in August 2011.
The standard was published this year (2011).
<p>
Following convention, the new standard is called C++11 (because it was published in 2011).
Personally, I prefer plain C++ and to use a year marker only when I need to distinguish it from
previous versions of C++, such as ARM C++, C++98 and C++03.
For a transition period, I still use C++0x in places.
Think of 'x' as hexadecimal.
</p><p>
</p><hr>
<h2 id="when-compilers">When will compilers implement C++11?</h2>
Currently shipping compilers (e.g. GCC C++, Clang C++,IBM C++, and Microsoft C++)
already implement many C++11 features.
For example, it seems obvious and popular to ship all or most of the new standard libraries.
<p>
I expect more and more features to become available with each new release.
I expect to see the first complete C++11 compiler sometime in 2012,
but I do not care to guess when such a compiler ships or when every compiler will provide all of C++11.
I note that
every C++11 feature has already been implemented by someone somewhere so there is implementation
experience available for implementers to rely on.
</p><p>
Here are links to C++11 information from purveyors:
</p><ul>
<li>
<a href="http://wiki.apache.org/stdcxx/C%2B%2B0xCompilerSupport">comparison</a>
</li><li>
<a href="http://gcc.gnu.org/projects/cxx0x.html">GCC</a>
</li><li>
<a href="http://www.ibm.com/software/awdtools/xlcpp/aix/features/?S_CMP=rnav">IBM</a>
</li><li>
<a href="http://msdn.microsoft.com/en-us/library/dd465215.aspx">Microsoft</a>
</li><li>
<a href="http://www.edg.com/index.php?location=c_lang">EDG</a>
</li><li>
<a href="http://clang.llvm.org/cxx_status.html">Clang</a>
</li></ul>



<p>
</p><hr>
<h2 id="when-libraries">When will the new standard libraries be available?</h2>
Initial versions of the new standard libraries are currently
shipping with the GCC,
<a href="http://libcxx.llvm.org/">Clang</a>
and Microsoft implementations,
and are available from
<a href="http://www.boost.org/">boost</a>.


<p>
</p><hr>
<h2 id="what-features">What new language features does C++11 provide?</h2>
You don't improve a language by simply adding every feature that someone considers a good idea.
In fact, essentially every feature of most modern languages has been suggested to me for C++
by someone: Try to imagine what the superset of C99, C#, Java, Haskell, Lisp, Python, and Ada would look like.
To make the problem more difficult, remember that it is not feasible to eliminate older features, even if
the committee agrees that they are bad: experience shows that users force every implementer to keep providing
deprecated and banned features under compatibility switches (or by default) for decades.
<p>
To try to select rationally from the flood of suggestions we devised a 
<a href="#specific-aims">set of specific design aims</a>.
We couldn't completely follow them and they weren't sufficiently complete to guide the
committee in every detail (and IMO couldn't possible be that complete).
</p><p>
The result has been a language with greatly improved abstraction mechanisms.
The range of abstractions that C++ can express elegantly, flexibly, and at zero costs compared to hand-crafted
specialized code has greatly increased.
When we say "abstraction" people often just think "classes" or "objects."
C++11 goes far beyond that: The range of user-defined types that can be cleanly and safely expressed has grown
with the addition of features such as
<a href="#init-list">initializer-lists</a>,
<a href="#uniform-init">uniform initialization</a>,
<a href="#template-alias">template aliases</a>,
<a href="#rval">rvalue references</a>,
<a href="#default">defaulted and deleted functions</a>,
and
<a href="#variadic-templates">variadic templates</a>.
Their implementation eased with features, such as
<a href="#auto">auto</a>,
<a href="#inheriting">inherited constructors</a>,
and
<a href="#decltype">decltype</a>.
These enhancements are sufficient to make C++11 feel like a new language.
</p><p>
For a list of accepted language features, see <a href="#language">the feature list</a>


</p><p>
</p><hr>
<h2 id="what-libraries">What new standard libraries does C++11 provide?</h2>
I would have liked to see more standard libraries.
However, note that the standard library definition is already about 70% of the normative text of the standard
(and that doesn't count the C standard library, which is included by reference).
Even though some of us would have liked to see many more standard libraries,
nobody could claim that the Library working group has been lazy.
It is also worth noting that the C++98 libraries have been significantly improved through the use of new
language features, such as
<a href="#init-list">initializer-lists</a>,
<a href="#rval">rvalue references</a>,
<a href="#variadic-templates">variadic templates</a>,
<a href="#noexcept">noexcept</a>, and
<a href="#constexpr">constexpr</a>.
The C++11 standard library is easier to use and provides better performance that
the C++98 one.
<p>
For a list of accepted libraries, see <a href="#library">the library component list</a>.


</p><p>
</p><hr>
<h2 id="aims">What were the aims of the C++11 effort?</h2>
<a href="http://www.stroustrup.com/C++.html">C++</a>
is a general-purpose programming language with a bias towards systems programming that
<ul>
<li>is a better C
</li><li>supports data abstraction
</li><li>supports object-oriented programming
</li><li>supports generic programming
</li></ul>
The overall aims of the C++11 effort was to strengthen that:
<ul>
<li>Make C++ a better language for systems programming and library building --
that is, to build directly on C++'s contributions to programming,
rather than providing specialized facilities for a particular sub-community
(e.g. numeric computation or Windows-style application development).
</li><li>Make C++ easier to teach and learn --
through increased uniformity, stronger guarantees, and facilities supportive of novices
(there will always be more novices than experts).
</li></ul>
Naturally, this is done under very stringent compatibility constraints.
Only very rarely is the committee willing to break standards conforming code,
though that's done when a new keyword
(e.g. <a href="#static_assert">static_assert</a>,
<a href="#nullptr">nullptr</a>,
and <a href="#constexpr">constexpr</a>) is introduced.
<p>
For more details see:
</p><ul>
<li>B. Stroustrup:
<a href="http://www.stroustrup.com/what-is-2009.pdf">What is C++11?</a>.
CVu.
Vol 21, Issues 4 and 5.
2009.
</li><li>B. Stroustrup:
<a href="http://www.stroustrup.com/hopl-almost-final.pdf">Evolving a language in and for the real world: C++ 1991-2006</a>.
ACM HOPL-III. June 2007.
</li><li>B. Stroustrup:
<a href="http://www.stroustrup.com/hopl2.pdf">A History of C++: 1979-1991</a>.
Proc ACM History of Programming Languages conference (HOPL-2). March 1993. 
</li><li>B. Stroustrup:
<a href="http://www.stroustrup.com/siblings_short.pdf">C and C++: Siblings</a>.
The C/C++ Users Journal. July 2002.
</li></ul>



<p>
</p><hr>
<h2 id="specific-aims">What specific design aims guided the committee?</h2>
Naturally, different people and different organizations involved with the standardization
have somewhat different aims, especially when it comes to details and to priorities.
Also, detailed aims change over time.
Please remember that the committee can't even do all that everyone agrees would be good things
-- it consists of volunteers with very limited resources.
However, here are a set of criteria that has seen real use in the
discussion of which features and libraries were appropriate for C++11:
<ul>
<li>Maintain stability and compatibility
-- don't break old code, and if you absolutely must, don't break it quietly.
</li><li>Prefer libraries to language extensions
-- an ideal at which the committee wasn't all that successful;
too many people in the committee and elsewhere prefer "real language features."
</li><li>Prefer generality to specialization
-- focus on improving the abstraction mechanisms (classes, templates, etc.).
</li><li>Support both experts and novices
-- novices can be helped by better libraries and through more general rules;
experts need general and efficient features.
</li><li>Increase type safety
-- primarily though facilities that allow programmers to avoid type-unsafe features.
</li><li>Improve performance and ability to work directly with hardware
-- make C++ even better for embedded systems programming and high-performance computation.
</li><li>Fit into the real world
-- consider tool chains, implementation cost, transition problems, ABI issues, teaching and learning, etc.
</li></ul>
Note that integrating features (new and old) to work in combination is the key
-- and most of the work.
The whole is much more than the simple sum of its parts.
<p>
Another way of looking at detailed aims is to look at areas of use and styles of usage:
</p><ul>
<li>Machine model and concurrency
-- provide stronger guarantees for and better facilities for using modern hardware
(e.g. multicores and weakly coherent memory models).
Examples are
the <a href="#std-threads">thread ABI</a>,
<a href="#std-future">futures</a>,
<a href="#thread-local">thread-local storage</a>,
and the <a href="#std-atomics">atomics ABI</a>.
</li><li>Generic programming
-- GP is among the great success stories of C++98;
we needed to improve support for it based on experience.
Examples are
<a href="#auto">auto</a> and
<a href="#template-alias">template aliases</a>.
</li><li>Systems programming
-- improve the support for close-to-the-hardware programming (e.g. low-level embedded systems programming)
and efficiency.
Examples are
<a href="#constexpr">constexpr</a>,
<a href="#std-array">std::array</a>,
and
<a href="#PODs">generalized PODs</a>.
</li><li>Library building
-- remove limitations, inefficiencies, and irregularities from the abstraction mechanisms.
Examples are
<a href="#inline-namespace">inline namespace</a>,
<a href="#inheriting">inherited constructors</a>,
and
<a href="#rval">rvalue references</a>.
</li></ul>


<p>
</p><hr>
<h2 id="WG21">Where can I find the committee papers?</h2>
Go to
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/">the papers section of the committee's website</a>.
There you will most likely drown in details.
Look for "issues lists" and "State of " (e.g.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2705.html">State of Evolution (July 2008)</a>)
lists. The key groups are
<ul>
<li>Core (CWG) -- dealing with language-technical issues and formulation
</li><li>Evolution (EWG) -- dealing with language feature proposals and issues crossing the language/library boundary
</li><li>Library (LWG) -- dealing with library facility proposals
</li></ul>
Here is the <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">latest draft C++11 standard</a>.





<p>
</p><hr>
<h2 id="technical-papers">Where can I find academic and technical papers about C++11?</h2>
<ul>
<li>Bjarne Stroustrup:
<a href="http://www.computer.org/portal/web/computingnow/0212/whatsnew/computer-r?src=cnhome-v1">Software Development for Infrastructure</a>.
Computer, vol. 45, no. 1, pp. 47-58, Jan. 2012, doi:10.1109/MC.2011.353.
<a href="http://vimeo.com/35326736">A video interview</a> about that paper and
<a href="http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Keynote-Bjarne-Stroustrup-Cpp11-Style">video of a talk on a very similar topic</a> (That's a 90 minute talk incl. Q&amp;A).

</li><li>Saeed Amrollahi:
<a href="http://www.saeedamrollahi.com/pub/C++0x.pdf">Modern Programming in the New Millenium: A Technical Survey on Outstanding features of C++0x</a>.
Computer Report (Gozaresh-e Computer), No.199, November 2011 (Mehr and Aban 1390), pages 60-82. (in Persian)

</li><li>Mark Batty et al's:
	<a href="http://portal.acm.org/citation.cfm?doid=1925844.1926394">Mathematizing C++ concurrency</a>,
	POPL 2012. // thorough, precise, and mathematical.

</li><li>Gabriel Dos Reis and Bjarne Stroustrup:
	<a href="http://www.stroustrup.com/sac10-constexpr.pdf">General Constant Expressions for System Programming Languages</a>.
	SAC-2010. The 25th ACM Symposium On Applied Computing. 

</li><li>Hans-J. Boehm and Sarita V. Adve:
<a href="http://portal.acm.org/citation.cfm?id=1375581.1375591">Foundations of the C++ concurrency memory model</a>.
ACM PLDI'08.

</li><li>Hans-J. Boehm:
<a href="http://www.hpl.hp.com/techreports/2009/HPL-2009-259html.html">Threads Basic</a>.
HPL technical report 2009-259
// ``what every programmer should know about memory model issues'' 

</li><li>Douglas Gregor, Jaakko Jarvi, Jeremy Siek, Bjarne Stroustrup, Gabriel Dos Reis, and Andrew Lumsdaine:
<a href="http://www.stroustrup.com/oopsla06.pdf">Concepts: Linguistic Support for Generic Programming in C++</a>.
OOPSLA'06, October 2006.
// The concept design and implementation as it stood in 2006; it has improved since,
<a href="#what-concepts">though not sufficiently to save it</a>.

</li><li>Douglas Gregor and Jaakko Jarvi:
<a href="http://www.jot.fm/issues/issue_2008_02/article2/">Variadic templates for C++0x</a>.
Journal of Object Technology, 7(2):31-51, February 2008.

</li><li>Jaakko Jarvi and John Freeman:
<a href="http://dx.doi.org/http://doi.acm.org/10.1145/1363686.1363735">Lambda functions for C++0x</a>.
ACM SAC '08.

</li><li>Jaakko Jarvi, Mat Marcus, and Jacob N. Smith:
<a href="">Programming with C++ Concepts</a>.
Science of Computer Programming, 2008.
To appear.

</li><li>M. Paterno and W. E. Brown :
<a href="">Improving Standard C++ for the Physics Community</a>.
CHEP'04.
// Much have been improved since then!

</li><li>Michael Spertus and Hans J. Boehm:
<a href="http://portal.acm.org/citation.cfm?doid=1542431.1542437">The Status of Garbage Collection in C++0X</a>.
ACM ISMM'09.

</li><li>Verity Stob:
<a href="http://www.theregister.co.uk/2009/05/07/verity_stob_cplusplus/">An unthinking programmer's guide to the new C++ -- Raising the standard</a>.
The Register. May 2009. (Humor (I hope)).

</li><li>[N1781=05-0041] Bjarne Stroustrup:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1781.pdf">Rules of thumb for the design of C++0x.

</a></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1781.pdf">Bjarne Stroustrup:
</a><a href="http://www.stroustrup.com/hopl-almost-final.pdf">Evolving a language in and for the real world: C++ 1991-2006</a>.
ACM HOPL-III. June 2007. (incl. slides and videos).
// Covers the design aims of C++0x, the standards process, and the progress up until 2007.

</li><li>B. Stroustrup:
<a href="http://www.stroustrup.com/what-is-2009.pdf">What is C++0x?</a>.
CVu.
Vol 21, Issues 4 and 5.
2009.

</li><li>Anthony Williams:
<a href="http://www.devx.com/SpecialReports/Article/38883">Simpler Multithreading in C++0x</a>. devx.com.

</li></ul>
This list is likely to be incomplete -- and likely to frequently go out of date as people write new papers.
If you find a paper that ought to be here and is not, please send it.
Also, not all papers will be completely up-to-date with the latest improvements of the standard.
I'll try to keep comments current.



<p>
</p><hr>
<h2 id="reading">Where else can I read about C++11?</h2>
The amount of information about C++11 is increasing as the standard nears completion and C++ implementations start
providing new language features and libraries.
Here is a short list of sources: 
<ul>
<li>B. Stroustrup:
<a href="http://www.stroustrup.com/4th.html">The C++ Programming Language (Fourth Edition)</a>.
</li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/">the papers section of the committee's website</a>.
</li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">C++11 draft</a>.
</li><li><a href="http://en.wikipedia.org/wiki/C%2B%2B0x">the C++11 Wikipedia entry</a>.
Seems to be actively maintained, though apparently not by members of the committee.
</li><li><a href="http://wiki.apache.org/stdcxx/C%2B%2B0xCompilerSupport">A list of support for C++11 features</a>.
</li></ul>



<p>
</p><hr>
<h2 id="videos">Are there any videos about C++11?</h2>
(To people who know me, this is a proof that this really is an FAQ, 
rather than a series of my own favorite questions;
I'm not a fan of videos on technical topics -- I find the video 
distracting and the verbal format too likely to contain minor technical 
errors).
<p>
Yes:
</p><ul>
<li> B. Stroustrup, H. Sutter, H-J. Boehm, A. Alexandrescu, S.T.Lavavej, Chandler Carruth, Andrew Sutter, and more:
several talks and panels from the <a href="http://channel9.msdn.com/Events/GoingNative/GoingNative-2012">Going Native 2012</a> conference.

</li><li> B. Stroustrup, H. Sutter, Sean Parent, Scott Meyers, and more:
several talks and panels from the <a href="http://channel9.msdn.com/Events/GoingNative/2013">Going Native 2013</a> conference.

</li><li>Herb Sutter:
<a href="http://channel9.msdn.com/Events/BUILD/BUILD2011/TOOL-835T">Writing modern C++ code: how C++ has evolved over the years</a>. September 2011.

</li><li>Herb Sutter:
<a href="http://channel9.msdn.com/posts/C-and-Beyond-2011-Herb-Sutter-Why-C">C++ and Beyond 2011: Herb Sutter - Why C++?</a>. August 2011.

</li><li><a href="http://video.google.com/videosearch?q=C%2B%2B0x&amp;oe=utf-8&amp;rls=org.mozilla:en-US:official&amp;client=firefox-a&amp;um=1&amp;ie=UTF-8&amp;sa=N&amp;hl=en&amp;tab=wv#">Try Google videos</a>.

</li><li>Lawrence Crowl:
<a href="http://www-sop.inria.fr/geometrica/events/WG21_meeting_june_2008/public_talks.html">Lawrence Crowl on C++ Threads</a>.
in Sophia Antipolis, June 2008.

</li><li>Bjarne Stroustrup:
<a href="http://www.youtube.com/watch?v=lMmVuRNmHzQ">The design of C++0x</a>
at U of Waterloo in 2007.

</li><li>Bjarne Stroustrup:
<a href="http://video.google.com/videoplay?docid=5262479012306588324&amp;ei=2eK7SaGiOILorgLo6p32CQ&amp;q=C%2B%2B0x&amp;hl=en">Initialization</a> at Google in 2007.

</li><li>Bjarne Stroustrup:
<a href="http://www-sop.inria.fr/geometrica/events/WG21_meeting_june_2008/public_talks.html">C++0x -- An overview</a>.
in Sophia Antipolis, June 2008.

</li><li>Lawrence Crowl:
<a href="http://video.google.com/videoplay?docid=3528799355371049884&amp;ei=NeS7SZLiCJGgqgKU_7GTCg&amp;q=C%2B%2B0x&amp;hl=en">Threads</a>.

</li><li>Roger Orr:
<a href="http://video.google.com/videoplay?docid=2165553273160626549&amp;ei=geS7SaSyNYL8rgL7643TDQ&amp;q=C%2B%2B0x&amp;hl=en">C++0x</a>. January 2008.

</li><li>Hans-Jurgen Boehm:
<a href="http://www.youtube.com/watch?v=mrvAqvtWYb4">Getting C++ Threads Right</a>. December 2007.
</li></ul>





<p>
</p><hr>
<h2 id="learn">Is C++11 hard to learn?</h2>
Well, since we can't remove any significant features from C++ without breaking large amounts of code, C++11 is larger
than C++98, so if you want to know every rule, learning C++11 will be harder. This leaves us with just two tools for
simplification (from the point of view of learners):
<ul>
<li>Generalization: Replace, say, three rules with one more general rule (e.g.,
<a href="#uniform-init">uniform initialization</a>,
<a href="#inheriting">inheriting constructors</a>, and
<a href="#std-threads">threads</a>).
</li><li>Simpler alternatives: Provide new facilities that are easier to use than their older alternatives (e.g.,
the 
<a href="#std-array">array</a>,
<a href="#auto">auto</a>,
<a href="#for">range-for statement</a>, and
<a href="#std-regex">regex</a>).
</li></ul>
Obviously, a "bottom up" teaching/learning style will nullify any such 
advantage, and there are currently (obviously) very little
material that takes a different approach.
That ought to change with time.

<p>
</p><hr>
<h2 id="committee-operate">How does the committee operate?</h2>
The ISO Standards committee, SC22 WG21, operates under the ISO rules for such committees.
Curiously enough, these rules are not standardized and change over time.
<p>
Many countries have national standards bodies with active C++ groups.
These groups hold meetings, coordinate over the web, and some send representatives to the ISO meetings.
Canada, France, Germany, Switzerland, UK, and USA are present at most meetings.
Denmark, the Netherlands, Japan, Norway, Spain, and others are represented in person less frequently.
</p><p>
Much of the work goes on in-between meetings over the web and the results are recorded as numbered committee papers on
the <a href="http://www.open-std.org/jtc1/sc22/wg21">WG21</a> website.
</p><p>
The committee meets two to three times a year for a week each time.
Most work at those meetings are in sub-working groups, such as "Core", "Library", "Evolution", and "Concurrency."
As needed, there are also in-between meetings of ad-hoc working groups on specific urgent topics,
such as "concepts" and "memory model."
Voting takes place at the main meetings.
First, working groups hold "straw votes" to see if an issue is ready for presentation to the committee as a whole.
Then, the committee as a whole votes (one member one vote) and if something is accepted the nations vote.
We take great care that we do not get into a situation where the majority present and the nations disagrees
-- proceeding if that is the case would guarantee long-term controversy.
Final votes on official drafts are done by mail by the national standards bodies.
</p><p>
The committee has formal liaison with the C standards group (SC22 WG14) and POSIX,
and more or less formal contacts with several other groups.
</p><p>
</p><hr>
<h2 id="committee-who">Who is on the committee?</h2>
The committee consists of a large number of people (about 250) out of whom 90+ turn up at the week-long
meetings two or three times a year.
In addition there are national standards groups and meetings in several countries.
Most members contribute either by attending meetings, by taking part in
email discussions, or by submitting papers for committee consideration.
Most members have friends and colleagues who help them.
From day #1, the committee has had members from many countries and at every meeting people from half a dozen to a dozen
countries attend.
The final votes are done by about 20 national standards bodies.
Thus, the ISO C++ standardization is a fairly massive effort, <i>not</i> a small coherent group of people working to
create a perfect language for "people just like themselves."
The standard is what this group of volunteers can agree on as being the best they can produce that <i>all</i> can live with.
<p>
Naturally, many (but not all) of these volunteers have day jobs focused on C++: We have compiler writers, tool builders,
library writers, application builders (too few of those), researchers (only a few), consultants, test-suite builders, and more.
</p><p>
Here is a very abbreviated list of organizations involved:
Adobe,
Apple,
Boost,
Bloomberg,
EDG,
Google,
HP,
IBM,
Intel,
Microsoft,
Red Hat,
Sun.
</p><p>
Here is a short list of names of members who you may have encountered in the literature or on the web:
<a href="http://en.wikipedia.org/wiki/David_Abrahams_%28computer_programmer%29">Dave Abrahams</a>,
<a href="http://lafstern.org/matt/">Matt Austern</a>,
<a href="http://www.petebecker.com/">Pete Becker</a>,
<a href="http://www.hpl.hp.com/personal/Hans_Boehm/">Hans Boehm</a>,
<a href="http://developers.sun.com/solaris/articles/mixing.html">Steve Clamage</a>,
<a href="http://www.crowl.org/lawrence/">Lawrence Crowl</a>,
<a href="http://www.boost.org/users/people/beman_dawes.html">Beman Dawes</a>,
<a href="http://www.spellen.org/youcandoit/about.htm">Francis Glassborow</a>,
<a href="http://www.linkedin.com/profile/view?id=13303189&amp;authType=NAME_SEARCH&amp;authToken=vkEV&amp;locale=en_US&amp;srchid=5202df78-b28d-4593-a123-7e2cee192998-0&amp;srchindex=1&amp;srchtotal=7&amp;pvs=ps&amp;pohelp=&amp;goback=.fps_*1_Doug_Gregor_*1_*1_*1_*1_*51_*1_Y_*1_*1_*1_false_1_R_true_*1_us%3A0_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2">Doug Gregor</a>,
<a href="http://www.linkedin.com/profile/view?id=298147&amp;authType=NAME_SEARCH&amp;authToken=ftzU&amp;locale=en_US&amp;srchid=bed30079-0f75-4ab1-adc7-86f7ee62348f-0&amp;srchindex=1&amp;srchtotal=3&amp;pvs=ps&amp;pohelp=&amp;goback=.fps_*1_Pablo_Halpern_*1_*1_*1_*1_*51_*1_Y_*1_*1_*1_false_1_R_true_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2">Pablo Halpern</a>,
<a href="http://www.boost.org/users/people/howard_hinnant.html">Howard Hinnant</a>,
<a href="http://parasol.tamu.edu/%7Ejarvi/">Jaakko Jarvi</a>,
<a href="http://www.linkedin.com/pub/john-lakos/4/117/888">John Lakos</a>,
Alisdair Meredith,
Jens Maurer,
Jason Merrill,
<a href="http://www.linkedin.com/profile/view?id=1899219&amp;authType=name&amp;authToken=Yn4O&amp;pvs=pp&amp;trk=ppro_viewmore">Sean Parent</a>,
<a href="http://en.wikipedia.org/wiki/P.J._Plauger">P.J. Plauger</a>,
<a href="http://www.linkedin.com/profile/view?id=1516413&amp;authType=NAME_SEARCH&amp;authToken=EHSf&amp;locale=en_US&amp;srchid=b18ef8ed-0c8c-430e-b1f7-99c3fcf3d000-0&amp;srchindex=1&amp;srchtotal=6&amp;pvs=ps&amp;pohelp=&amp;goback=.fps_*1_Tom_Plum_*1_*1_*1_*1_*51_*1_Y_*1_*1_*1_false_1_R_true_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2_*2">Tom Plum</a>,
<a href="http://parasol.tamu.edu/%7Egdr/">Gabriel Dos Reis</a>,
<a href="http://www2.research.att.com/%7Ebs/">Bjarne Stroustrup</a>,
<a href="http://en.wikipedia.org/wiki/Herb_Sutter">Herb Sutter</a>,
<a href="http://www.vandevoorde.com/">David Vandevoorde</a>,
<a href="http://www.linkedin.com/pub/michael-wong/15/58/217">Michael Wong</a>.
Apologies to the 200+ current and past members that I couldn't list.
Also, please note the author lists on the various papers: a standard is 
written by (many) individuals, not by an anonymous committee.
</p><p>
You can get a better impression of the breath and depth of expertise involved by examining the author lists on the
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/">WG21 papers</a>,
but please remember there are major contributors to the standards effort who do not write a lot.




</p><p>
</p><hr>
<h2 id="1x">Will there be a C++1y?</h2>
Almost certainly -- and not just because the committee has slipped the 
deadline for C++0x.
The plans for minor revisions, C++14, are well advanced (the features 
have been voted into the working draft and implemented), and the plan is
 for a major revision in 2017, C++17.





<p>
</p><hr>
<h2 id="what-concepts">What happened to "concepts"?</h2>
"Concepts" was a feature designed to allow precise specification of requirements on template
arguments. Unfortunately, the committee decided that further work on concepts could seriously delay the standard
and voted to remove the feature from the working paper, see my note
<a href="http://www.ddj.com/cpp/218600111">The C++0x "Remove Concepts" Decision</a> and
<a href="http://www.devx.com/cplus/Article/42448">A DevX interview on concepts and the implications for C++0x</a> 
for an explanation.
<p>
A radically simplified version ``concepts lite'' will be part of C++14 (as a technical report).
</p><p>
I have not deleted the concept sections from this document, but left them at the end:
</p><ul>
<li><a href="#axioms">axioms</a> (semantic assumptions)
</li><li><a href="#concepts">concepts</a>
</li><li><a href="#concept_maps">concept maps</a>
</li></ul>

<p>
</p><hr>
<h2 id="bad-features">Are there any features you don't like?</h2>
Yes.
There are also features in C++98 that I don't like, such as macros.
The issue is not whether I like something or if I find it useful for something I want to do.
The issue is whether someone has felt enough of a need to convince others to support the idea
or possibly if some usage is so ingrained in a user community that it needs support.

<p>
</p><hr>
<h2 id="11">__cplusplus</h2>
In C++11 the macro <b>__cplusplus</b> will be set to a value that differs from (is greater than) the current <b>199711L</b>.



<p>
</p><hr>
<h2 id="auto">auto -- deduction of a type from an initializer</h2>
Consider
<pre><b>
	auto x = 7;
</b></pre>
Here <b>x</b> will have the type <b>int</b> because that's the type of its initializer. In general, we can write
<pre><b>
	auto x = expression;
</b></pre>
and the type of <b>x</b> will be the type of the value computed from "expression".
<p>
The use of <b>auto</b> to deduce the type of a variable from its initializer is obviously most useful when that type
is either hard to know exactly or hard to write. Consider:
</p><pre><b>
	template&lt;class T&gt; void printall(const vector&lt;T&gt;&amp; v)
	{
		for (auto p = v.begin(); p!=v.end(); ++p)
			cout &lt;&lt; *p &lt;&lt; "\n";
	}
</b></pre>
In C++98, we'd have to write
<pre><b>
	template&lt;class T&gt; void printall(const vector&lt;T&gt;&amp; v)
	{
		for (typename vector&lt;T&gt;::const_iterator p = v.begin(); p!=v.end(); ++p)
			cout &lt;&lt; *p &lt;&lt; "\n";
	}
</b></pre>
<p>
When the type of a variable depends critically on template argument it can be really hard to write code without <b>auto</b>.
For example:
</p><pre><b>
	template&lt;class T, class U&gt; void multiply(const vector&lt;T&gt;&amp; vt, const vector&lt;U&gt;&amp; vu)
	{
		// ...
		auto tmp = vt[i]*vu[i];
		// ...
	}
</b></pre>
The type of <b>tmp</b> should be what you get from multiplying a <b>T</b> by a <b>U</b>,
but exactly what that is can be hard
for the human reader to figure out,
but of course the compiler knows once it has figured out what particular <b>T</b> and <b>U</b>
it is dealing with.
<p>
The <b>auto</b> feature has the distinction to be the earliest to be suggested and implemented:
I had it working in my Cfront implementation in early 1984,
but was forced to take it out because of C compatibility problems.
Those compatibility problems disappeared when C++98 and C99 accepted the removal of "implicit <b>int</b>";
that is, both languages require every variable and function to be defined with an explicit type.
The old meaning of <b>auto</b> ("this is a local variable") is now illegal.
Several committee members trawled through millions of lines of code finding only a handful of uses -- and most
of those were in test suites or appeared to be bugs.
</p><p>
Being primarily a facility to simplify notation in code, <b>auto</b> does not affect the standard library specification.</p><p>
See also
</p><ul>
<li>the C++ draft section 7.1.6.2, 7.1.6.4, 8.3.5 (for return types)
</li><li>[N1984=06-0054] Jaakko Jarvi, Bjarne Stroustrup, and Gabriel Dos Reis:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1984.pdf">Deducing the type of variable from its initializer expression (revision 4)</a>.
</li></ul>



<p>
</p><hr>
<h2 id="for">Range-for statement</h2>
A range for statement allows you to iterate through a "range",
which is anything you can iterate through like an STL-sequence defined by a begin() and end().
All standard containers can be used as a range, as can a std::string, an initializer list, an array,
and anything for which you define begin() and end(), e.g. an istream.
For example:
<pre><b>
void f(vector&lt;double&gt;&amp; v)
{
	for (auto x : v) cout &lt;&lt; x &lt;&lt; '\n';
	for (auto&amp; x : v) ++x;	// </b>using a reference to allow us to change the value<b>
}
</b></pre>
You can read that as "for all x in v" going through starting with v.begin() and iterating to v.end().
Another example:
<pre><b>
	for (const auto x : { 1,2,3,5,8,13,21,34 }) cout &lt;&lt; x &lt;&lt; '\n';
</b></pre>
The <b>begin()</b> (and <b>end()</b>) can be a member to be called <b>x.begin()</b> or a free-standing function to be called <b>begin(x)</b>.
The member version takes precedence.
<p>
See also
</p><ul>
<li>the C++ draft section 6.5.4 (note: changed not to use concepts)
</li><li>[N2243==07-0103] Thorsten Ottosen:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2243.html">Wording for range-based for-loop (revision 2)</a>.
</li><li> [N3257=11-0027 ] Jonathan Wakely and Bjarne Stroustrup: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3257.pdf"> Range-based for statements and ADL</a> (Option 5 was chosen).
</li></ul>


<p>
</p><hr>
<h2 id="brackets">right-angle brackets</h2>
Consider
<pre><b>
	list&lt;vector&lt;string&gt;&gt; lvs;
</b></pre>
In C++98 this is a syntax error because there is no space between the two &gt;s.
C++11 recognizes such two <b>&gt;</b>s as a correct termination of two template argument lists.
<p>
Why was this ever a problem?
A compiler front-end is organized parses/stages.
This is about the simplest model:
</p><ul>
<li>lexical analysis (make up tokens from characters)
</li><li>syntax analysis (check the grammar)
</li><li>type checking (find the type of names and expressions)
</li></ul>
These stages are in theory and sometimes in practice strictly separate,
so the lexical analyzer that determines that <b>&gt;&gt;</b> is a token (usually meaning right-shift or input) has no idea
of its meaning; in particular, it has no idea of templates or nested template argument lists.
However, to get that example "correct" the three stages has somehow to cooperate.
The key observation that led to the problem being resolved was that every C++ compiler already did understand the problem
so that it could give decent error messages.
<p>
See also
</p><ul>
<li>the C++ draft section ???
</li><li>[N1757==05-0017] Daveed Vandevoorde:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html">revised right angle brackets proposal (revision 2)</a>.
</li></ul>



<p>
</p><hr>
<h2 id="default">control of defaults: default and delete</h2>
The common idiom of "prohibiting copying" can now be expressed directly:
<pre><b>
	class X {
		// </b>...<b>
		X&amp; operator=(const X&amp;) = delete;	// </b>Disallow copying<b>
		X(const X&amp;) = delete;
	};
</b></pre>
Conversely, we can also say explicitly that we want to default copy behavior:
<pre><b>
	class Y {
		// </b>...<b>
		Y&amp; operator=(const Y&amp;) = default;	// </b>default copy semantics<b>
		Y(const Y&amp;) = default;
	};
</b></pre>
Being explicit about the default is redundant.
However, comments about copy operations and (worse)
a user explicitly defining copy operations meant to give the default behavior are not uncommon.
Leaving it to the compiler to implement the default behavior is simpler, less error-prone,
and often leads to better object code.
<p>
The "default" mechanism can be used for any function that has a default.
The "delete" mechanism can be used for any function. For example, we can
eliminate an undesired conversion like this:
</p><pre><b>
	struct Z {
		// </b>...<b>

		Z(long long);     // </b>can initialize with an long long<b>
		Z(long) = delete; // </b>but not anything less<b>
	};
</b></pre>
<p>
See also
</p><ul>
<li>the C++ draft section ???
</li><li>[N1717==04-0157] Francis Glassborow and Lois Goldthwaite:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1717.pdf">explicit class and default definitions</a> (an early proposal).
</li><li>Bjarne Stroustrup:
<a href="http://www.stroustrup.com/http::/www.research.att.com/%7Ebs/controlofdefaults.pdf">Control of class defaults</a> (a dead end).
</li><li>[N2326==07-0186] Lawrence Crowl:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2326.html">Defaulted and Deleted Functions</a>.
</li><li>[N3174=100164] B. Stroustrup: 
<a href="http://www.stroustrup.com/move.pdf">To move or not to move</a>.
An analysis of problems related to generated copy and move operations.
Approved.
</li></ul>



<hr>
<h2 id="default2">control of defaults: move and copy</h2>
By default, a class has 5 operations:
<ul>
<li>copy assignment
</li><li>copy constructor
</li><li>move assignment
</li><li>move constructor
</li><li>destructor
</li></ul>
If you declare any of those you must consider all and explicitly define or default the ones you want.
Think of copying, moving, and destruction as closely related operations, rather than individual operations
that you can freely mix and match - you can specify arbitrary combinations, but only a few combinations make
sense semantically.
<p>
If any move, copy, or destructor is explicitly specified (declared, defined,
<a href="#default">=default</a><a>,
or =delete) by the user, no move is generated by default. 
If any move, copy, or destructor is explicitly specified (declared, 
defined, =default, or =delete) by the user, any undeclared copy 
operations are generated by default, but this is deprecated, so don't 
rely on that. 
For example:
</a></p><pre><a><b>
	class X1 {
		X1&amp; operator=(const X1&amp;) = delete;	// </b>Disallow copying<b>
	};
</b></a></pre><a>
This implicitly also disallows moving of <b>X1</b>s.
Copy initialization is allowed, but deprecated.
<pre><b>
	class X2 {
		X2&amp; operator=(const X2&amp;) = delete;
	};
</b></pre>
This implicitly also disallows moving of <b>X2</b>s.
Copy initialization is allowed, but deprecated.
<pre><b>
	class X3 {
		X3&amp; operator=(X3&amp;&amp;) = delete;	// </b>Disallow moving<b>
	};
</b></pre>
This implicitly also disallows copying of <b>X3</b>s.
<pre><b>
	class X4 {
		~X4() = delete;	// </b>Disallow destruction<b>
	};
</b></pre>
This implicitly also disallows moving of <b>X4</b>s.
Copying is allowed, but deprecated.
<p>
I strongly recommend that if you declare one of these five function, you explicitly declare all.
For example:
</p><pre><b>
	template&lt;class T&gt;
	class Handle {
		T* p;
	public:
		Handle(T* pp) : p{pp} {}
		~Handle() { delete p; }		// </b>user-defined destructor: no implicit copy or move<b> 

		Handle(Handle&amp;&amp; h) :p{h.p} { h.p=nullptr; }			// </b>transfer ownership<b>
		Handle&amp; operator=(Handle&amp;&amp; h) { delete p; p=h.p; h.p=nullptr; return *this; }	// </b>transfer ownership<b>

		Handle(const Handle&amp;) = delete;		// </b>no copy<b>
		Handle&amp; operator=(const Handle&amp;) = delete;

		// </b>...<b>
	};
</b></pre>
<p>
See also
</p></a><ul><a>
<li>the C++ draft section ???
</li></a><li><a>[N2326==07-0186] Lawrence Crowl:
</a><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2326.html">Defaulted and Deleted Functions</a>.
</li><li>[N3174=100164] B. Stroustrup: 
<a href="http://www.stroustrup.com/move.pdf">To move or not to move</a>.
An analysis of problems related to generated copy and move operations.
Approved.
</li></ul>


<p>
</p><hr>
<h2 id="enum">enum class -- scoped and strongly typed enums</h2>
The <b>enum class</b>es ("new enums", "strong enums") address three problems with traditional C++
enumerations:
<ul>
<li>conventional <b>enum</b>s implicitly convert to <b>int</b>,
causing errors when someone does not want an enumeration to act as an integer.
</li><li>conventional <b>enum</b>s export their enumerators to the surrounding scope,
causing name clashes.
</li><li>the underlying type of an <b>enum</b> cannot be specified,
causing confusion, compatibility problems, and makes forward declaration impossible.
</li></ul>
<p>
<b>enum class</b>s ("strong enums") are strongly typed and scoped:
</p><pre><b>
	enum Alert { green, yellow, orange, red }; // </b>traditional enum<b>

	enum class Color { red, blue };   // </b>scoped and strongly typed enum<b>
	                                  // </b>no export of enumerator names into enclosing scope<b>
	                                  // </b>no implicit conversion to int<b>
	enum class TrafficLight { red, yellow, green };

	Alert a = 7;              // </b>error (as ever in C++)<b>
	Color c = 7;              // </b>error: no int-&gt;Color conversion<b>

	int a2 = red;             // </b>ok: Alert-&gt;int conversion<b>
	int a3 = Alert::red;      // </b>error in C++98; ok in C++11<b>
	int a4 = blue;            // </b>error: blue not in scope<b>
	int a5 = Color::blue;     // </b>error: not Color-&gt;int conversion<b>

	Color a6 = Color::blue;   // </b>ok<b>
</b></pre>
As shown, traditional <b>enum</b>s work as usual,
but you can now optionally qualify with the <b>enum</b>'s name.
<p>
The new enums are "enum class" because they combine aspects of traditional enumerations
(names values) with aspects of classes (scoped members and absence of conversions).
</p><p>
Being able to specify the underlying type allow simpler interoperability and guaranteed sizes of
enumerations: 
</p><pre><b>
	enum class Color : char { red, blue };	// </b>compact representation<b>

	enum class TrafficLight { red, yellow, green };  // </b>by default, the underlying type is int<b>

	enum E { E1 = 1, E2 = 2, Ebig = 0xFFFFFFF0U };   // </b>how big is an E?<b>
	                                                 // </b>(whatever the old rules say;<b>
	                                                 // </b>i.e. "implementation defined")<b>

	enum EE : unsigned long { EE1 = 1, EE2 = 2, EEbig = 0xFFFFFFF0U };   // </b>now we can be specific<b>
</b></pre>
It also enables forward declaration of <b>enum</b>s: 
<pre><b>
	enum class Color_code : char;     // </b>(forward) declaration<b>
	void foobar(Color_code* p);       // </b>use of forward declaration<b>
	// </b>...<b>
	enum class Color_code : char { red, yellow, green, blue }; // </b>definition<b>
</b></pre>
The underlying type must be one of the signed or unsigned integer types; the default is <b>int</b>.
<p>
In the standard library, enum classes are used
</p><ul>
<li>For mapping systems specific error codes:
In &lt;system_error&gt;:
enum class errc;
</li><li>For pointer safety indicators:
In &lt;memory&gt;:
enum class pointer_safety { relaxed, preferred, strict };
</li><li>For I/O stream errors:
In &lt;iosfwd&gt;:
enum class io_errc { stream = 1 };
</li><li>For asynchronous communications error handling:
In &lt;future&gt;:
enum class future_errc { broken_promise, future_already_retrieved, promise_already_satisfied };
</li></ul>
Several of these have operators, such as == defined.
<p>
See also
</p><ul>
<li>the C++ draft section 7.2
</li><li>[N1513=03-0096] David E. Miller:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1513.pdf">Improving Enumeration Types</a> (original enum proposal).
</li><li>[N2347 = J16/07-0207] David E. Miller, Herb Sutter, and  Bjarne Stroustrup:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf">Strongly Typed Enums (revision 3)</a>.
</li><li>[N2499=08-0009] Alberto Ganesh Barbati:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2499.pdf">Forward declaration of enumerations</a>.
</li></ul>



<p>
</p><hr>
<h2 id="constexpr">constexpr -- generalized and guaranteed constant expressions</h2>
The <b>constexpr</b> mechanism
<ul>
<li>provides more general constant expressions
</li><li>allows constant expressions involving user-defined types
</li><li>provides a way to guarantee that an initialization is done at compile time
</li></ul>
Consider
<pre><b>
	enum Flags { good=0, fail=1, bad=2, eof=4 };

	constexpr int operator|(Flags f1, Flags f2) { return Flags(int(f1)|int(f2)); }

	void f(Flags x)
	{
		switch (x) {
		case bad:         /* </b>...<b> */ break;
		case eof:         /* </b>...<b> */ break;
		case bad|eof:     /* </b>...<b> */ break;
		default:          /* </b>...<b> */ break;
		}
	}
</b></pre>
Here <b>constexpr</b> says that the function must be of a simple form so that it can be evaluated
at compile time if given constant expressions arguments. 
<p>
In addition to be able to evaluate expressions at compile time, we want to be able to <i>require</i>
expressions to be evaluated at compile time;
<b>constexpr</b> in front of a variable definition does that (and implies <b>const</b>):
</p><pre><b>
	constexpr int x1 = bad|eof;	// </b>ok<b>

	void f(Flags f3)
	{
		constexpr int x2 = bad|f3;	// </b>error: can't evaluate at compile time<b>
		int x3 = bad|f3;		// </b>ok<b>
	}
</b></pre>
Typically we want the compile-time evaluation guarantee for global or namespace objects, often for
objects we want to place in read-only storage.
<p>
This also works for objects for which the constructors are simple enough to be <b>constexpr</b>
and expressions involving such objects:
</p><pre><b>
	struct Point {
		int x,y;
		constexpr Point(int xx, int yy) : x(xx), y(yy) { }
	};

	constexpr Point origo(0,0);
	constexpr int z = origo.x;

	constexpr Point a[] = {Point(0,0), Point(1,1), Point(2,2) };
	constexpr int x = a[1].x;	// </b>x becomes 1<b>
</b></pre>
Please note that <b>constexpr</b> is not a general purpose replacement for <b>const</b> (or vise versa):
<ul>
<li><b>const</b>'s primary function is to express the idea that an object is not modified through an interface
(even though the object may very well be modified through other interfaces).
It just so happens that declaring an object <b>const</b> provides excellent optimization opportunities for the compiler.
In particular, if an object is declared <b>const</b> and its address isn't taken, a compiler is often
able to evaluate its initializer at compile time (though that's not guaranteed)
and keep that object in its tables rather than emitting it into the generated code.
</li><li><b>constexpr</b>'s primary function is to extend the range of what can be computed at compile time,
making such computation type safe.
Objects declared <b>constexpr</b> have their initializer evaluated at compile time;
they are basically values kept in the compiler's tables and only emitted into
the generated code if needed.
</li></ul>
<p>
See also
</p><ul>
<li>the C++ draft 3.6.2 Initialization of non-local objects, 3.9 Types 
[12], 5.19 Constant expressions, 7.1.5 The constexpr specifier
</li><li>[N1521=03-0104] Gabriel Dos Reis:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1521.pdf">Generalized Constant Expressions</a> (original proposal).
</li><li>[N2235=07-0095] Gabriel Dos Reis, Bjarne Stroustrup, and Jens Maurer:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2235.pdf">Generalized Constant Expressions -- Revision 5</a>.
</li></ul>


<p>
</p><hr>
<h2 id="decltype"><b>decltype</b> -- the type of an expression</h2>
<b>decltype(E)</b> is the type ("declared type") of the name or expression <b>E</b> and can be used
in declarations. For example:
<pre><b>
	void f(const vector&lt;int&gt;&amp; a, vector&lt;float&gt;&amp; b)
	{
		typedef decltype(a[0]*b[0]) Tmp;
		for (int i=0; i&lt;b.size(); ++i) {
			Tmp* p = new Tmp(a[i]*b[i]);
			// </b>...<b>
		}
		// </b>...<b>
	}
</b></pre>
This notion has been popular in generic programming under the label "typeof" for a long time,
but the <b>typeof</b> implementations in actual use were incomplete and incompatible,
so the standard version is named <b>decltype</b>.
<p>
If you just need the type for a variable that you are about to initialize <a href="#auto">auto</a> is often a
simpler choice. You really need <b>decltype</b> if you need a type for something that is not a variable,
such as a
<a href="#suffix-return">return type</a>.
</p><p>
See also
</p><ul>
<li>the C++ draft 7.1.6.2 Simple type specifiers
</li><li>[Str02] Bjarne Stroustrup. Draft proposal for "typeof". C++ 
reflector message c++std-ext-5364, October 2002. (original suggestion).
</li><li>[N1478=03-0061] Jaakko Jarvi,  Bjarne Stroustrup, Douglas Gregor, and Jeremy Siek:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1478.pdf">Decltype and auto</a> (original proposal).
</li><li>[N2343=07-0203] Jaakko Jarvi, Bjarne Stroustrup, and Gabriel Dos Reis:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2343.pdf">Decltype (revision 7): proposed wording</a>.
</li></ul>




<p>
</p><hr>
<h2 id="init-list">Initializer lists</h2>
Consider
<pre> <b>
	vector&lt;double&gt; v = { 1, 2, 3.456, 99.99 };
	list&lt;pair&lt;string,string&gt;&gt; languages = {
		{"Nygaard","Simula"}, {"Richards","BCPL"}, {"Ritchie","C"}
	}; 
	map&lt;vector&lt;string&gt;,vector&lt;int&gt;&gt; years = {
		{ {"Maurice","Vincent", "Wilkes"},{1913, 1945, 1951, 1967, 2000} },
		{ {"Martin", "Ritchards"}, {1982, 2003, 2007} }, 
		{ {"David", "John", "Wheeler"}, {1927, 1947, 1951, 2004} }
	}; 
</b></pre>
Initializer lists are not just for arrays any more.
The mechanism for accepting a <b>{}</b>-list is a function (often a constructor)
accepting an argument of type <b>std::initializer_list&lt;T&gt;</b>. For example:
<pre><b>
	void f(initializer_list&lt;int&gt;);
	f({1,2});
	f({23,345,4567,56789});
	f({});	// </b>the empty list<b>
	f{1,2};	// </b>error: function call ( ) missing<b>

	years.insert({{"Bjarne","Stroustrup"},{1950, 1975, 1985}});
</b></pre>
The initializer list can be of arbitrary length, but must be homogeneous
(all elements must be of a the template argument type, <b>T</b>, or convertible to <b>T</b>).
<p>
A container might implement an initializer-list constructor like this:
</p><pre><b>
	template&lt;class E&gt; class vector {
	public:
   		vector (std::initializer_list&lt;E&gt; s) // </b>initializer-list constructor<b>
   		{
      			reserve(s.size());	// </b>get the right amount of space<b>
      			uninitialized_copy(s.begin(), s.end(), elem);	// </b>initialize elements (in elem[0:s.size()))<b>
			sz = s.size();	// </b>set vector size<b>
   		}
   	
		// </b>... as before ...<b>
	};
</b></pre>
<p>
The distinction between direct initialization and copy initialization is maintained for <b>{}</b>-initialization,
but becomes relevant less frequently because of  <b>{}</b>-initialization.
For example, <b>std::vector</b> has an <b>explicit</b> constructor from <b>int</b> and an initializer-list constructor:
</p><pre><b>
	vector&lt;double&gt; v1(7);	// </b>ok: v1 has 7 elements<b>
	v1 = 9;			// </b>error: no conversion from int to vector<double><b>
	vector&lt;double&gt; v2 = 9;	// </b>error: no conversion from int to vector<double><b>

	void f(const vector&lt;double&gt;&amp;);
	f(9);				// </b>error: no conversion from int to vector<double><b>

	vector&lt;double&gt; v1{7};		// </b>ok: v1 has 1 element (with its value 7.0)<b>
	v1 = {9};			// </b>ok v1 now has 1 element (with its value 9.0)<b>
	vector&lt;double&gt; v2 = {9};	// </b>ok: v2 has 1 element (with its value 9.0)<b>
	f({9});				// </b>ok: f is called with the list { 9 }<b>

	vector&lt;vector&lt;double&gt;&gt; vs = {
		vector&lt;double&gt;(10), 	// </b>ok: explicit construction (10 elements)<b>
		vector&lt;double&gt;{10},	// </b>ok: explicit construction (1 element with the value 10.0)<b>
		10 			// </b>error: vector's constructor is explicit<b>
	};	
</b></double></double></double></pre>
<p>
The function can access the <b>initializer_list</b> as an immutable sequence. For example:
</p><pre><b>
	void f(initializer_list&lt;int&gt; args)
	{
		for (auto p=args.begin(); p!=args.end(); ++p) cout &lt;&lt; *p &lt;&lt; "\n";
	}
</b></pre>
<p>
A constructor that takes a single argument of type <b>std::initializer_list</b> is called an initializer-list constructor.
</p><p>
The standard library containers, <b>string</b>, and <b>regex</b> have initializer-list constructors, assignment, etc.
An initializer-list can be used as a range, e.g. in a <a href="#for">range for statement</a>
</p><p>
The initializer lists are part of the scheme for
<a href="#uniform-init">uniform and general initialization</a>.
</p><p>
See also
</p><ul>
<li>the C++ draft 8.5.4 List-initialization [dcl.init.list]
</li><li>[N1890=05-0150 ]  Bjarne Stroustrup and Gabriel Dos Reis:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1890.pdf">Initialization and initializers</a>
(an overview of initialization-related problems with suggested solutions).
</li><li>[N1919=05-0179]  Bjarne Stroustrup and Gabriel Dos Reis:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1919.pdf">Initializer lists</a>.
</li><li>[N2215=07-0075] Bjarne Stroustrup and Gabriel Dos Reis :
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2215.pdf">Initializer lists (Rev. 3) </a>.
</li><li>[N2640=08-0150] Jason Merrill and Daveed Vandevoorde:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2640.pdf">Initializer Lists -- Alternative Mechanism and Rationale (v. 2)</a> (final proposal).
</li></ul>



<p>
</p><hr>
<h2 id="narrowing">Preventing narrowing</h2>
The problem: C and C++ implicitly truncates:
<pre><b>
	int x = 7.3;		// </b>Ouch!<b>
	void f(int);
	f(7.3);			// </b>Ouch!<b>
</b></pre>
However, in C++11, <b>{}</b> initialization doesn't narrow:
<pre><b>
	int x0 {7.3};	// </b>error: narrowing<b>
	int x1 = {7.3};	// </b>error: narrowing<b>
	double d = 7;
	int x2{d};		// </b>error: narrowing (double to int)<b>
	char x3{7};		// </b>ok: even though 7 is an int, this is not narrowing<b>
	vector&lt;int&gt; vi = { 1, 2.3, 4, 5.6 };	// </b>error: double to int narrowing<b>
</b></pre>
The way C++11 avoids a lot of incompatibilities is by relying on the actual values of initializers
(such as 7 in the example above)
when it can (and not just type) when deciding what is a narrowing conversion.
If a value can be represented exactly as the target type, the conversion is not narrowing.
<pre>	char c1{7};      // OK: 7 is an int, but it fits in a char
	char c2{77777};  // error: narrowing (assuming 8-bit chars)
</pre>
Note that floating-point to integer conversions are always considered narrowing -- even 7.0 to 7.
<p>
See also
</p><ul>
<li>the C++ draft section 8.5.4.
</li><li>[N1890=05-0150 ]  Bjarne Stroustrup and Gabriel Dos Reis:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1890.pdf">Initialization and initializers</a>
(an overview of initialization-related problems with suggested solutions).
</li><li>[N2215=07-0075] Bjarne Stroustrup and Gabriel Dos Reis :
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2215.pdf">Initializer lists (Rev. 3) </a>.

</li><li>[N2640=08-0150] Jason Merrill and Daveed Vandevoorde:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2640.pdf">Initializer Lists - Alternative Mechanism and Rationale (v. 2)</a> 
(primarily on "explicit").
</li></ul>




<p>
</p><hr>
<h2 id="delegating-ctor">Delegating constructors</h2>
In C++98, if you want two constructors to do the same thing, repeat yourself or call "an init() function."
For example:
<pre><b>
	class X {
		int a;
		void validate(int x) { if (0&lt;x &amp;&amp; x&lt;=max) a=x; else throw bad_X(x); }
	public:
		X(int x) { validate(x); }
		X() { validate(42); }
		X(string s) { int x = lexical_cast&lt;int&gt;(s); validate(x); }
		// </b>...<b>
	};
</b></pre>

<p>
Verbosity hinders readability and repetition is error-prone. Both get in the way of maintainability.
So, in C++11, we can define one constructor in terms of another:
</p><pre><b>
	class X {
		int a;
	public:
		X(int x) { if (0&lt;x &amp;&amp; x&lt;=max) a=x; else throw bad_X(x); }
		X() :X{42} { }
		X(string s) :X{lexical_cast&lt;int&gt;(s)} { }
		// </b>...<b>
	};
</b></pre>
<p>
See also
</p><ul>
<li>the C++ draft section 12.6.2
</li><li>N1986==06-0056 Herb Sutter and Francis Glassborow:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986">Delegating Constructors (revision 3)</a>.
</li></ul>


<p>
</p><hr>
<h2 id="member-init">In-class member initializers</h2>
In C++98, only static const members of integral types can be initialized in-class,
and the initializer has to be a constant expression.
These restrictions ensure that we can do the initialization at compile-time.
For example:
<pre><b>
	int var = 7;

	class X {
		static const int m1 = 7;        // </b>ok<b>
		const int m2 = 7;                	// </b>error: not static<b>
		static int m3 = 7;              // </b>error: not const<b>
		static const int m4 = var;       	// </b>error: initializer not constant expression<b>
		static const string m5 = "odd"; // </b>error: not integral type<b>
		// </b>...<b>
	};
</b></pre>
The basic idea for C++11 is to allow a non-static data member to be initialized where
it is declared (in its class).
A constructor can then use the initializer when run-time initialization is needed.
Consider:
<pre><b>
	class A {
	public:
		int a = 7;
	};
</b></pre>
This is equivalent to:
<pre><b>
	class A {
	public:
		int a;
		A() : a(7) {}
	};
</b></pre>
This saves a bit of typing, but the real benefits come in classes with multiple constructors.
Often, all constructors use a common initializer for a member:
<pre><b>
	class A {
	public:
		A(): a(7), b(5), hash_algorithm("MD5"), s("Constructor run") {}
		A(int a_val) : a(a_val), b(5), hash_algorithm("MD5"), s("Constructor run") {}
		A(D d) : a(7), b(g(d)), hash_algorithm("MD5"), s("Constructor run") {}
		int a, b;
	private:
		HashingFunction hash_algorithm;  // </b>Cryptographic hash to be applied to all A instances<b>
		std::string s;                   // </b>String indicating state in object lifecycle<b>
	};
</b></pre>
The fact that <b>hash_algorithm</b> and <b>s</b> each has a single default is lost in the mess of code and could
easily become a problem during maintenance.
Instead, we can factor out the initialization of the data members:
<pre><b>
	class A {
	public:
		A(): a(7), b(5) {}
		A(int a_val) : a(a_val), b(5) {}
		A(D d) : a(7), b(g(d)) {}
		int a, b;
	private:
		HashingFunction hash_algorithm{"MD5"};  // </b>Cryptographic hash to be applied to all A instances<b>
		std::string s{"Constructor run"};       // </b>String indicating state in object lifecycle<b>
	};
</b></pre>
If a member is initialized by both an in-class initializer and a constructor, only the constructor's
initialization is done (it "overrides" the default). So we can simplify further:
<pre><b>
	class A {
	public:
		A() {}
		A(int a_val) : a(a_val) {}
		A(D d) : b(g(d)) {}
		int a = 7;
		int b = 5;	
	private:
		HashingFunction hash_algorithm{"MD5"};  // </b>Cryptographic hash to be applied to all A instances<b>
		std::string s{"Constructor run"};       // </b>String indicating state in object lifecycle<b>
    };
</b></pre>
<p>
See also
</p><ul>
<li>the C++ draft section "one or two words all over the place"; see proposal.
</li><li>[N2628=08-0138] Michael Spertus and Bill Seymour:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2628.html">Non-static data member initializers</a>.
</li></ul>


<p>
</p><hr>
<h2 id="inheriting">Inherited constructors</h2>
People sometimes are confused about the fact that ordinary scope rules apply to class members.
In particular, a member of a base class is not in the same scope as a member of a derived class:
<pre><b>
	struct B {
		void f(double);
	};

	struct D : B {
		void f(int);
	};

	B b;   b.f(4.5);	// </b>fine<b>
	D d;   d.f(4.5);	// </b>surprise: calls f(int) with argument 4<b>
</b></pre>
In C++98, we can "lift" a set of overloaded functions from a base class into a derived class:
<pre><b>
	struct B {
		void f(double);
	};

	struct D : B {
		using B::f;     // </b>bring all f()s from B into scope<b>
		void f(int);    // </b>add a new f()<b>
	};

	B b;   b.f(4.5);	// </b>fine<b>
	D d;   d.f(4.5);	// </b>fine: calls D::f(double) which is B::f(double)<b>
</b></pre>
I have said that "Little more than a historical accident prevents using this to work for a constructor
as well as for an ordinary member function."
C++11 provides that facility:
<pre><b>
	class Derived : public Base { 
	public: 
		using Base::f;    // </b>lift Base's f into Derived's scope -- works in C++98<b>
		void f(char);     // </b>provide a new f<b> 
		void f(int);      // </b>prefer this f to Base::f(int)<b> 

		using Base::Base; // </b>lift Base constructors Derived's scope -- C++11 only<b>
		Derived(char);    // </b>provide a new constructor<b> 
		Derived(int);     // </b>prefer this constructor to Base::Base(int)<b> 
		// </b>...<b>
	}; 
</b></pre>
<p>
If you so choose, you can still shoot yourself in the foot by inheriting constructors in a derived class
in which you define new member variables needing initialization:
</p><pre><b>
	struct B1 {
		B1(int) { }
	};

	struct D1 : B1 {
		using B1::B1; // </b>implicitly declares D1(int)<b>
		int x;
	};

	void test()
	{
		D1 d(6);	// </b>Oops: d.x is not initialized<b>
		D1 e;		// </b>error: D1 has no default constructor<b>
	}
</b></pre>
You might remove the bullet from your foot by using a
<a href="#member-init">member-initializer</a>:
<pre><b>
    	struct D1 : B1 {
    		using B1::B1;	// </b>implicitly declares D1(int)<b>
    		int x{0};	// </b>note: x is initialized<b>
    	};

    	void test()
    	{
    		D1 d(6);	// </b>d.x is zero<b>
    	}
</b></pre>
<p>
See also
</p><ul>
<li>the C++ draft section 12.9.
</li><li>[N1890=05-0150 ]  Bjarne Stroustrup and Gabriel Dos Reis:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1890.pdf">Initialization and initializers</a>
(an overview of initialization-related problems with suggested solutions).
</li><li>[N1898=05-0158 ] Michel Michaud and Michael Wong: 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1898.pdf">Forwarding and inherited constructors </a>.
</li><li>[N2512=08-0022] Alisdair Meredith, Michael Wong, Jens Maurer:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2512.html">Inheriting Constructors (revision 4)</a>.
</li></ul>





<p>
</p><hr>
<h2 id="static_assert"><b>Static (compile-time) assertions</b> -- static_assert</h2>
A static (compile time) assertion consists of a constant expression and a string literal:
<pre><b>
	static_assert(expression,string);
</b></pre>
The compiler evaluates the expression and writes the string as an error message if the expression is false
(i.e., if the assertion failed). For example:
<pre><b>
	static_assert(sizeof(long)&gt;=8, "64-bit code generation required for this library.");
	struct S { X m1; Y m2; };
	static_assert(sizeof(S)==sizeof(X)+sizeof(Y),"unexpected padding in S");
</b></pre>
A <b>static_assert</b> can be useful to make assumptions about a program and its treatment by a compiler explicit.
Note that since <b>static_assert</b> is evaluated at compile time, it cannot be used to check assumptions that
depends on run-time values. For example:
<pre><b>
	int f(int* p, int n)
	{
		static_assert(p==0,"p is not null");	// </b>error: static_assert() expression not a constant expression<b>
		// </b>...<b>
	}
</b></pre>
(instead, test and throw an exception in case of failure).
<p>
See also
</p><ul>
<li>the C++ draft 7 [4].
</li><li>[N1381==02-0039] Robert Klarer and John Maddock:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1381.htm">Proposal to Add Static Assertions to the Core Language</a>.
</li><li>[N1720==04-0160] Robert Klarer, John Maddock, Beman Dawes, Howard Hinnant:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1720.html">Proposal to Add Static Assertions to the Core Language (Revision 3)</a>.
</li></ul>

<p>
</p><hr>
<h2 id="long-long"><b>long long</b> -- a longer integer</h2>
An integer that's at least 64 bits long.
For example:
<pre><b>
	long long x = 9223372036854775807LL;
</b></pre>
No, there are no <b>long long long</b>s nor can <b>long</b> be spelled <b>short long long</b>.
<p>
See also
</p><ul>
<li>the C++ draft ???.
</li><li>[05-0071==N1811] J. Stephen Adamczyk:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1811.pdf">Adding the long long type to C++ (Revision 3)</a>.
</li></ul>




<p>
</p><hr>
<h2 id="nullptr"><b>nullptr</b> -- a null pointer literal</h2>
<b>nullptr</b> is a literal denoting the null pointer;
it is not an integer:
<pre><b>
	char* p = nullptr;
	int* q = nullptr;
	char* p2 = 0;		// </b>0 still works and p==p2<b>

	void f(int);
	void f(char*);

	f(0);         		// </b>call f(int)<b>
	f(nullptr);   		// </b>call f(char*)<b>

	void g(int);
	g(nullptr);		// </b>error: nullptr is not an int<b>
	int i = nullptr;	// </b>error nullptr is not an int<b>
</b></pre>
<p>
See also
</p><ul>
<li>the C++ draft section ???
</li><li>[N1488==/03-0071]  Herb Sutter and Bjarne Stroustrup:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1488.pdf">A name for the null pointer: nullptr </a>.
</li><li>[N2214 = 07-0074 ]  Herb Sutter and Bjarne Stroustrup:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2431.pdf">A name for the null pointer: nullptr (revision 4) </a>.
</li></ul>


<p>
</p><hr>
<h2 id="suffix-return">Suffix return type syntax</h2>
Consider:
<pre><b>
	template&lt;class T, class U&gt;
	??? mul(T x, U y)
	{
		return x*y;
	}
</b></pre>
What can we write as the return type? It's "the type of <b>x*y</b>",
of course, but how can we say that?
First idea, use <a href="#decltype">decltype</a>:
<pre><b>
	template&lt;class T, class U&gt;
	decltype(x*y) mul(T x, U y) // </b>scope problem!<b>
	{
		return x*y;
	}
</b></pre>
That won't work because <b>x</b> and <b>y</b> are not in scope.
However, we can write:
<pre><b>
	template&lt;class T, class U&gt;
	decltype(*(T*)(0)**(U*)(0)) mul(T x, U y)	// </b>ugly! and error prone<b>
	{
		return x*y;
	}
</b></pre>
However, calling that "not pretty" would be overly polite.
<p>
The solution is put the return type where it belongs, after the arguments:
</p><pre><b>
	template&lt;class T, class U&gt;
	auto mul(T x, U y) -&gt; decltype(x*y)
	{
		return x*y;
	}
</b></pre>
We use the notation <b>auto</b> to mean "return type to be deduced or specified later."
<p>
The suffix syntax is not primarily about templates and type deduction, it is really about scope.
</p><pre><b>
	struct List {
		struct Link { /* </b>...<b> */ };
		Link* erase(Link* p);	// </b>remove p and return the link before p<b>
		// </b>...<b>
	};

	List::Link* List::erase(Link* p) { /* </b>...<b> */ }
</b></pre>
The first <b>List::</b> is necessary only because the scope of <b>List</b> isn't entered
until the second <b>List::</b>.
Better:
<pre><b>
	auto List::erase(Link* p) -&gt; Link* { /* </b>...<b> */ }
</b></pre>
Now neither <b>Link</b> needs explicit qualification.
<p>
See also
</p><ul>
<li>the C++ draft section ???
</li><li>[Str02] Bjarne Stroustrup. Draft proposal for "typeof". C++ reflector message c++std-ext-5364, October 2002.
</li><li>[N1478=03-0061]  Jaakko Jarvi, Bjarne Stroustrup, Douglas Gregor, and Jeremy Siek:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1478.pdf">Decltype and auto</a>.
</li><li>[N2445=07-0315] Jason Merrill:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2445.html">New Function Declarator Syntax Wording</a>.
</li><li>[N2825=09-0015] Lawrence Crowl and Alisdair Meredith:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2825.html">Unified Function Syntax</a>.
</li></ul>


<p>
</p><hr>
<h2 id="template-alias">template alias (formerly known as "template typedef")</h2>
How can we make a template that's "just like another template" but 
possibly with a couple of template arguments specified (bound)?
Consider:
<pre><b>
	template&lt;class T&gt;
	using Vec = std::vector&lt;T,My_alloc&lt;T&gt;&gt;;  // </b>standard vector using my allocator<b>

	Vec&lt;int&gt; fib = { 1, 2, 3, 5, 8, 13 }; // </b>allocates elements using My_alloc<b>

	vector&lt;int,My_alloc&lt;int&gt;&gt; verbose = fib; // </b>verbose and fib are of the same type<b>
</b></pre>
The keyword <b>using</b> is used to get a linear notation "name followed by what it refers to."
We tried with the conventional and convoluted <b>typedef</b> solution, but never managed to get
a complete and coherent solution until we settled on a less obscure syntax.
<p>
Specialization works
(you can alias a set of specializations but you cannot specialize an alias)
For example:
<b></b></p><pre><b>	template&lt;int&gt;
	struct int_exact_traits {	// </b>idea: int_exact_trait&lt;N&gt;::type is a type with exactly N bits<b>
		typedef int type;
	};

	template&lt;&gt;
	struct int_exact_traits&lt;8&gt; {
		typedef char type;
	};

	template&lt;&gt;
	struct int_exact_traits&lt;16&gt; {
		typedef char[2] type;
	};

	// </b>...<b>

	template&lt;int N&gt;
	using int_exact = typename int_exact_traits&lt;N&gt;::type;  // </b>define alias for convenient notation<b>

	int_exact&lt;8&gt; a = 7;	// </b>int_exact&lt;8&gt; is an int with 8 bits<b>
</b></pre>
In addition to being important in connection with templates, type aliases can also be used as a different
(and IMO better) syntax for ordinary type aliases:
<pre><b>
typedef void (*PFD)(double);	// </b>C style<b>
using PF = void (*)(double);	// </b>using plus C-style type<b>
using P = [](double)-&gt;void;	// </b>using plus suffix return type<b>
</b></pre>
<p>
See also
</p><ul>
<li>the C++ draft: 14.6.7 Template aliases; 7.1.3 The typedef specifier
</li><li> [N1489=03-0072] Bjarne Stroustrup and Gabriel Dos Reis:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1489.pdf">Templates aliases for C++</a>.
</li><li>[N2258=07-0118] Gabriel Dos Reis and Bjarne Stroustrup:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2258.pdf">Templates Aliases (Revision 3)</a> (final proposal).
</li></ul>






<p>
</p><hr>
<h2 id="variadic-templates">Variadic Templates</h2>
Problems to be solved:
<ul>
<li>How to construct a class with 1, 2, 3, 4, 5, 6, 7, 8, 9, or ... initializers?
</li><li>How to avoid constructing an object out of parts and then copying the result?
</li><li>How to construct a tuple?
</li></ul>
The last question is the key: Think tuple! If you can make and access general tuples the rest will follow.
<p>
Here is an example (from ``A brief introduction to Variadic templates'' (see references)) implementing a general, type-safe, <b>printf()</b>.
It would probably be better to use <b>boost::format</b>, but consider:
</p><pre><b>
	const string pi = "pi";
	const char* m = "The value of %s is about %g (unless you live in %s).\n";
	printf(m,pi,3.14159,"Indiana");

</b></pre>
The simplest case of <b>printf()</b> is when there are no arguments except the format string, so we'll handle that first:
<pre><b>
	void printf(const char* s)	
	{
		while (s &amp;&amp; *s) {
		 	if (*s=='%' &amp;&amp; *++s!='%')	// </b>make sure that there wasn't meant to be more arguments<b>
							// </b>%% represents plain % in a format string<b>
		         throw runtime_error("invalid format: missing arguments");
			std::cout &lt;&lt; *s++;
		}
	}

</b></pre>
That done, we must handle <b>printf()</b> with more arguments:
<pre><b>
	template&lt;typename T, typename... Args&gt;		// </b>note the "..."<b>
	void printf(const char* s, T value, Args... args)	// </b>note the "..."<b>
	{
		while (s &amp;&amp; *s) {
			if (*s=='%' &amp;&amp; *++s!='%') {	// </b>a format specifier (ignore which one it is)<b>
				std::cout &lt;&lt; value;		// </b>use first non-format argument<b>
				return printf(++s, args...); 	// </b>``peel off'' first argument<b>
			}
			std::cout &lt;&lt; *s++;
		}
		throw std::runtime error("extra arguments provided to printf");
	}

</b></pre>
This code simply ``peels off'' the first non-format argument and then calls itself recursively.
When there are no more non-format arguments, it calls the first (simpler) <b>printf()</b> (above).
This is rather standard functional programming done at compile time.
Note how the overloading of <b>&lt;&lt;</b> replaces the use of the (possibly erroneous) ``hint'' in the format specifier.
<p>
The <b>Args...</b>defines what is called a ``parameter pack.''
That's basically a sequence of (type/value) pairs from which you can ``peel off'' arguments starting with the first.
When <b>printf()</b> is called with one argument, the first definition (<b>printf(const char*)</b>) is chosen.
When <b>printf()</b> is called with two or more arguments, the second definition (<b>printf(const char*, T value, Args... args)</b>) is chosen,
with the first argument as <b>s</b>, the second as <b>value</b>, and the rest (if any) bundled into the parameter pack <b>args</b>
for later use.
In the call
</p><pre><b>
	printf(++s, args...); 
</b></pre>
The parameter pack <b>args</b> is expanded so that the next argument can now be selected as <b>value</b>.
This carries on until <b>args</b> is empty (so that the first <b>printf()</b> is called).
<p>
If you are familiar with functional programming, you should find this an unusual notation for a pretty standard technique.
If not, here are some small technical examples that might help.
First we can declare and use a simple variadic template function (just like <b>printf()</b> above):
</p><pre><b>
	template&lt;class ... Types&gt; 
		void f(Types ... args);	// </b>variadic template function<b>
					// </b>(i.e. a function that can take an arbitrary number of arguments of arbitrary types)<b>
	f();	 	// </b>OK: args contains no arguments<b>
	f(1);	 	// </b>OK: args contains one argument: int<b>
	f(2, 1.0); 	// </b>OK: args contains two arguments: int and double<b>
</b></pre>
We can build a variadic type:
<pre><b>	
	template&lt;typename Head, typename... Tail&gt;
	class tuple&lt;Head, Tail...&gt;
		: private tuple&lt;Tail...&gt; {	// </b>here is the recursion<b>
				// </b>Basically, a tuple stores its head (first (type/value) pair<b> 
				// </b>and derives from the tuple of its tail (the rest of the (type/value) pairs.<b>
				// </b>Note that the type is encoded in the type, not stored as data<b>
		typedef tuple&lt;Tail...&gt; inherited;
	public:
		tuple() { }	// </b>default: the empty tuple<b>

		// </b>Construct tuple from separate arguments:<b>
		tuple(typename add_const_reference&lt;Head&gt;::type v, typename add_const_reference&lt;Tail&gt;::type... vtail)
			: m_head(v), inherited(vtail...) { }

		// </b>Construct tuple from another tuple:<b>
		template&lt;typename... VValues&gt;
		tuple(const tuple&lt;VValues...&gt;&amp; other)
		:	 m_head(other.head()), inherited(other.tail()) { }

		template&lt;typename... VValues&gt;
		tuple&amp; operator=(const tuple&lt;VValues...&gt;&amp; other)	// </b>assignment<b>
		{
			m_head = other.head();
			tail() = other.tail();
			return *this;
		}

		typename add_reference&lt;Head&gt;::type head() { return m_head; }
		typename add_reference&lt;const Head&gt;::type head() const { return m_head; }

		inherited&amp; tail() { return *this; }
		const inherited&amp; tail() const { return *this; }
	protected:
		Head m_head;
	}
</b></pre>
Given that definition, we can make tuples (and copy and manipulate them):
<pre><b>
	tuple&lt;string,vector&lt;int&gt;,double&gt; tt("hello",{1,2,3,4},1.2);
	string h = tt.head();	// </b>"hello"<b>
	tuple&lt;vector&lt;int&gt;,double&gt; t2 = tt.tail();	// </b>{{1,2,3,4},1.2};<b>
</b></pre>
It can get a bit tedious to mention all of those types, so often, we 
deduce them from argument types, e.g. using the standard library <b>make_tuple()</b>:
<pre><b>
	template&lt;class... Types&gt;
	tuple&lt;Types...&gt; make_tuple(Types&amp;&amp;... t)	// </b>this definition is somewhat simplified (see standard 20.5.2.2)<b>
	{
		return tuple&lt;Types...&gt;(t...);
	}
	
	string s = "Hello";
	vector&lt;int&gt; v = {1,22,3,4,5};
	auto x = make_tuple(s,v,1.2);
</b></pre>
<p>
See also:
</p><ul>
<li>Standard 14.6.3 Variadic templates
</li><li>[N2151==07-0011] D. Gregor, J. Jarvi:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2151.pdf">Variadic Templates for the C++0x Standard Library</a>.
</li><li>[N2080==06-0150] D. Gregor, J. Jarvi, G. Powell:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2080.pdf">Variadic Templates (Revision 3)</a>.
</li><li>[N2087==06-0157] Douglas Gregor:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2087.pdf">A Brief Introduction to Variadic Templates</a>.
</li><li>[N2772==08-0282] L. Joly, R. Klarer:
 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2772.pdf">Variadic functions: Variadic templates or initializer lists? -- Revision 1</a>.
</li><li>[N2551==08-0061] Sylvain Pion:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2551.pdf">A Variadic std::min(T, ...) for the C++ Standard Library (Revision 2) </a>.
</li><li>Anthony Williams:
<a href="http://www.devx.com/cplus/Article/41533">An Introduction to Variadic Templates in C++0x</a>.
DevX.com, May 2009.
</li></ul>


<p>
</p><hr>
<h2 id="uniform-init">Uniform initialization syntax and semantics</h2>
C++ offers several ways of initializing an object depending on its type and the initialization context.
When misused, the error can be surprising and the error messages obscure.
Consider:
<pre><b>
	string a[] = { "foo", " bar" };          // </b>ok: initialize array variable<b>
	vector&lt;string&gt; v = { "foo", " bar" };    // </b>error: initializer list for non-aggregate vector<b>
	void f(string a[]);
	f( { "foo", " bar" } );                  // </b>syntax error: block as argument<b>
</b></pre>
and
<pre><b>
	int a = 2;              // </b>``assignment style''<b>
	int aa[] = { 2, 3 };    // </b>assignment style with list<b>
	complex z(1,2);         // </b>``functional style'' initialization<b>
	x = Ptr(y);             // </b>``functional style'' for conversion/cast/construction<b>
</b></pre>
and
<pre><b>
	int a(1);	// </b>variable definition<b>
	int b();	// </b>function declaration<b>
	int b(foo);	// </b>variable definition or function declaration<b>
</b></pre>
It can be hard to remember the rules for initialization and to choose the best way.
<p>
The C++11 solution is to allow <b>{}</b>-initializer lists for all initialization:
</p><pre><b>
	X x1 = X{1,2}; 
	X x2 = {1,2}; 	// </b>the = is optional<b>
	X x3{1,2}; 
	X* p = new X{1,2}; 

	struct D : X {
		D(int x, int y) :X{x,y} { /* </b>...<b> */ };
	};

	struct S {
		int a[3];
		S(int x, int y, int z) :a{x,y,z} { /* </b>...<b> */ }; // </b>solution to old problem<b>
	};
</b></pre>
Importantly, <b>X{a}</b> constructs the same value in every context,
so that <b>{}</b>-initialization gives the same result in all places where it is legal.
For example:
<pre><b>
	X x{a}; 
	X* p = new X{a};
	z = X{a};         // </b>use as cast<b>
	f({a});           // </b>function argument (of type X)<b>
	return {a};       // </b>function return value (function returning X)<b>
</b></pre>
<p>
See also
</p><ul>
<li>the C++ draft section ???
</li><li>
[N2215==07-0075 ]  Bjarne Stroustrup and Gabriel Dos Reis:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2215.pdf">Initializer lists (Rev. 3) </a>.
</li><li>[N2640==08-0150] Jason Merrill and  Daveed Vandevoorde:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2640.pdf">Initializer Lists -- Alternative Mechanism and Rationale (v. 2)</a> (final proposal).
</li></ul>



<p>
</p><hr>
<h2 id="rval">Rvalue references</h2>
The distinction between lvalues (what can be used on the left-hand side of an assignment) and rvalues
(what can be used on the right-hand side of an assignment) goes back to Christopher Strachey
(the father of C++'s distant ancestor CPL and of denotational semantics).
In C++, non-const references can bind to lvalues and const references can bind to lvalues or rvalues,
but there is nothing that can bind to a non-const rvalue.
That's to protect people from changing the values of temporaries that are destroyed before
their new value can be used.
For example:
<pre><b>
	void incr(int&amp; a) { ++a; }
	int i = 0;
	incr(i);	// </b>i becomes 1<b>
	incr(0);	// </b>error: 0 is not an lvalue<b>
</b></pre> 
If that <b>incr(0)</b> were allowed either some temporary that nobody ever saw would be incremented or - far worse -
the value of 0 would become 1.
The latter sounds silly, but there was actually a bug like that in early Fortran compilers that set aside a memory
location to hold the value 0.
<p>
So far, so good, but consider
</p><pre><b>
	template&lt;class T&gt; swap(T&amp; a, T&amp; b)		// </b>"old style swap"<b>
	{
		T tmp(a);	// </b>now we have two copies of a<b>
		a = b;		// </b>now we have two copies of b<b>
		b = tmp;	// </b>now we have two copies of tmp (aka a)<b>
	} 
</b></pre>
If <b>T</b> is a type for which it can be expensive to copy elements, such as string and vector, swap becomes an expensive 
operation (for the standard library, we have specializations of string and vector <b>swap()</b> to deal with that).
Note something curious: We didn't want any copies at all. We just wanted to move the values of <b>a</b>, <b>b</b>,
and <b>tmp</b> around a bit.
<p>
In C++11, we can define "move constructors" and "move assignments" to move rather than copy their argument:
</p><pre><b>
	template&lt;class T&gt; class vector {
		// </b>...<b>
		vector(const vector&amp;);	 		// </b>copy constructor<b>
		vector(vector&amp;&amp;);	 		// </b>move constructor<b>
		vector&amp; operator=(const vector&amp;);	// </b>copy assignment<b>
		vector&amp; operator=(vector&amp;&amp;);		// </b>move assignment<b>
	};	// </b>note: move constructor and move assignment takes non-const &amp;&amp;<b>
		// </b>they can, and usually do, write to their argument<b>
</b></pre>
The &amp;&amp; indicates an "rvalue reference".
An rvalue reference can bind to an rvalue (but not to an lvalue):
<pre><b>
	X a;
	X f();
	X&amp; r1 = a;		// </b>bind r1 to a (an lvalue)<b>
	X&amp; r2 = f();		// </b>error: f() is an rvalue; can't bind<b>

	X&amp;&amp; rr1 = f();	// </b>fine: bind rr1 to temporary<b>
	X&amp;&amp; rr2 = a;	// </b>error: bind a is an lvalue<b>
</b></pre>
The idea behind a move assignment is that instead of making a copy, it simply takes the representation from its source and
replaces it with a cheap default. For example, for strings <b>s1=s2</b> using the move assignment would not make a copy of
<b>s2</b>'s characters; instead, it would just let <b>s1</b> treat those characters as its own and somehow delete <b>s1</b>'s
old characters (maybe by leaving them in <b>s2</b>, which presumably are just about to be destroyed).
<p>
How do we know whether it's ok to simply move from a source? We tell the compiler:
</p><pre><b>
	template&lt;class T&gt; 
	void swap(T&amp; a, T&amp; b)	// </b>"perfect swap" (almost)<b>
	{
		T tmp = move(a);	// </b>could invalidate a<b>
		a = move(b);		// </b>could invalidate b<b>
		b = move(tmp);		// </b>could invalidate tmp<b>
	}
</b></pre> 
<b>move(x)</b> means "you can treat <b>x</b> as an rvalue".
Maybe it would have been better if <b>move()</b> had been called <b>rval()</b>,
but by now <b>move()</b> has been used for years.
The <b>move()</b> template function can be written in C++11 (see the "brief introduction") and uses rvalue references.
<p>
Rvalue references can also be used to provide perfect forwarding.
</p><p>
In the C++11 standard library, all containers are provided with move constructors and move assignment and
operations that insert new elements, such as <b>insert()</b> and <b>push_back()</b> have versions that take rvalue references.
The net result is that the standard containers and algorithms quietly - without user intervention - improve in performance
because they copy less.
</p><p>
See also
</p><ul>
<li>the C++ draft section ???
</li><li>N1385 N1690 N1770 N1855 N1952 
</li><li>[N2027==06-0097] Howard Hinnant, Bjarne Stroustrup, and Bronek Kozicki:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html">A brief introduction to rvalue references</a>
</li><li>[N1377=02-0035] Howard E. Hinnant, Peter Dimov, and Dave Abrahams:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">A Proposal to Add Move Semantics Support to the C++ Language</a> (original proposal).
</li><li>[N2118=06-0188] Howard Hinnant:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2118.html">A Proposal to Add an Rvalue Reference to the C++ Language Proposed Wording (Revision 3)</a> (final proposal).
</li></ul>



<p>
</p><hr>
<h2 id="unions">unions (generalized)</h2>
In C++98 (as in the earlier versions of C++),
a member with a user-defined constructor, destructor, or assignment cannot be a member of a union:
<pre><b>
	union U {
		int m1;
		complex&lt;double&gt; m2;	// </b>error (silly): complex has constructor<b>
		string m3;		// </b>error (not silly): string has a serious invariant <b>
				// </b>maintained by ctor, copy, and dtor<b>
	};
</b></pre>
In particular
<pre><b>
	U u;			// </b>which constructor, if any?<b>
	u.m1 = 1;		// </b>assign to int member<b>
	string s = u.m3;	// </b>disaster: read from string member<b>
</b></pre>
Obviously, it's illegal to write one member and then read another
but people do that nevertheless (usually by mistake).
<p>
C++11 modifies the restrictions of unions to make more member types feasible; in particular,
it allows a member of types with constructors and destructors.
It also adds a restriction to make
the more flexible unions less error-prone by encouraging the building of discriminated unions.
</p><p>
Union member types are restricted:
</p><ul>
<li>No virtual functions (as ever)
</li><li>No references (as ever)
</li><li>No bases (as ever)
</li><li>If a union has a member with a user-defined constructor, copy, or destructor then that special function is
<a href="#default">deleted</a>;
that is, it cannot be used for an object of the union type. This is new.
</li></ul>
For example:
<pre><b>
	union U1 {
		int m1;
		complex&lt;double&gt; m2;	// </b>ok<b>
	};
	
	union U2 {
		int m1;
		string m3;	// </b>ok<b>
	};
</b></pre>
This may look error-prone, but the new restriction helps.
In particular:
<pre><b>
	U1 u;  		// </b>ok<b>
	u.m2 = {1,2};	// </b>ok: assign to the complex member<b>
	U2 u2;		// </b>error: the string destructor caused the U2 destructor to be deleted<b>
	U2 u3 = u2;	// </b>error: the string copy constructor caused the U2 copy constructor to be deleted<b>
</b></pre>
Basically, <b>U2</b> is useless unless you embed it in a struct that keeps track of which member (variant) is used.
So, build discriminate unions, such as:
<pre><b>
	class Widget {	// </b>Three alternative implementations represented as a union<b>
	private:
		enum class Tag { point, number, text } type;	// </b>discriminant<b>
		union {		// </b>representation<b>
			point p;	  // </b>point has constructor<b>
			int i;
			string s;	 // </b>string has default constructor, copy operations, and destructor<b>
		};
		// </b>...<b>
		Widget&amp; operator=(const Widget&amp; w) 	// </b>necessary because of  the string variant<b>
		{
			if (type==Tag::text &amp;&amp; w.type==Tag::text) {
				s = w.s;		// </b>usual string assignment<b>
				return *this;
			}

			if (type==Tag::text) s.~string();	// </b>destroy (explicitly!)<b>

			switch (w.type) {
			case Tag::point: p = w.p; break;	// </b>normal copy<b>
			case Tag::number: i = w.i; break;
			case Tag::text: new(&amp;s)(w.s); break;	// </b>placement new<b>
			}
			type = w.type;
			return *this;
		}
	};
</b></pre>
See also:
<ul>
li&gt;the C++ draft section 9.5
<li>[N2544=08-0054]  Alan Talbot, Lois Goldthwaite,  Lawrence Crowl, and Jens Maurer:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2544.pdf">Unrestricted unions (Revision 2)</a>
</li></ul>




<p>
</p><hr>
<h2 id="PODs">PODs (generalized)</h2>
A POD ("Plain Old Data") is something that can be manipulated like a C struct,
e.g. copies with <b>memcpy()</b>, initializes with <b>memset()</b>, etc.
In C++98 the actual definition of POD is based on a set of restrictions on the use of language
features used in the definition of a struct:
<pre> <b>
	struct S { int a; };	// </b>S is a POD<b>
	struct SS { int a; SS(int aa) : a(aa) { } }; // </b>SS is not a POD<b>
	struct SSS { virtual void f(); /* </b>...<b> */ };
</b></pre>
In C++11, S and SS are "standard layout types" (a.k.a. POD) because there is really nothing
"magic" about SS: the constructor does not affect the layout (so memcpy() would be fine),
only the initialization rules (memset() would be bad - not enforcing the invariant).
However, SSS will still have an embedded vptr and will not be anything like "plain old data."
C++11 defines POD, trivially copyable types, trivial types, and standard-layout types to deal
with various technical aspects of what used to be PODs.
POD is defined recursively
<ul>
<li>If all your members and bases are PODs, you're a POD
</li><li>As usual (details in section 9 [10])
<ul>
<li>No virtual functions
</li><li>No virtual bases
</li><li>No references
</li><li>No multiple access specifiers
</li></ul>
</li></ul>
The most important aspect of C++11 PODs are that
adding or subtracting constructors do not affect layout or performance.
<p>
See also:
</p><ul>
<li>the C++ draft section 3.9 and 9 [10]
</li><li>[N2294=07-0154] Beman Dawes: 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2294.html">POD's Revisited; Resolving Core Issue 568 (Revision 4)</a>.
</li></ul>





<p>
</p><hr>
<h2 id="raw-strings">Raw string literals</h2>
In many cases, such as when you are writing regular expressions for the use with the standard
<a href="#std-regex">regex</a> library, the fact that a backslash (\) is an escape character is a real nuisance
(because in regular expressions backslash is used to introduce special characters representing character classes).
Consider how to write the pattern representing two words separated by a backslash (<b>\w\\\w</b>):
<pre><b>
	string s = "\\w\\\\\\w";	// </b>I hope I got that right<b>
</b></pre>
Note that the backslash character is represented as two backslashes in a regular expression.
Basically, a "raw string literal" is a string literal where a backslash is just a backslash so that our example
becomes:
<pre><b>
	string s = R"(\w\\\w)";	// </b>I'm pretty sure I got that right<b>
</b></pre>
The original proposal for raw strings presents this as a motivating example
<pre><b>
    "('(?:[^\\\\']|\\\\.)*'|\"(?:[^\\\\\"]|\\\\.)*\")|"	// </b>Are the five backslashes correct or not?<b>
							// </b>Even experts become easily confused.<b> 
</b></pre>
The <b>R"(...)"</b> notation is a bit more verbose than the "plain" <b>"..."</b> but "something more" is necessary when you
don't have an escape character: How do you put a quote in a raw string? Easy, unless it is preceded by a <b>)</b>:
<pre><b>
	R"("quoted string")"	// </b>the string is "quoted string"<b>
</b></pre>
So, how do we get the character sequence <b>)"</b> into a raw string? Fortunately, that's a rare problem,
but <b>"(...)"</b> is only the default delimiter pair.
We can add delimiters before and after the <b>(...)</b> in <b>"(...)"</b>. For example
<pre><b>
	R"***("quoted string containing the usual terminator (")")***"	// </b>the string is "quoted string containing the usual terminator (")"<b>
</b></pre>
The character sequence after <b>)</b> must be identical to the sequence before the <b>(</b>.
This way we can cope with (almost) arbitrarily complicated patterns.
<p>
The initial <b>R</b> of a raw string can be preceded by an encoding-prefix: <b>u8</b>, <b>u</b>, <b>U</b>, or <b>L</b>.
For example <b>u8R"(fdfdfa)"</b> is an UTF-8 string literal.
</p><p>
See
</p><ul>
<li> Standard 2.13.4
</li><li>[N2053=06-0123] Beman Dawes:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2053.html">Raw string literals</a>. (original proposal)
</li><li>[N2442=07-0312] Lawrence Crowl and Beman Dawes:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2442.htm">Raw and Unicode String Literals; Unified Proposal (Rev. 2)</a>.
(final proposal combined with the
<a href="#UD-literals">User-defined literals</a> proposal).
</li><li>[N3077==10-0067] Jason Merrill: 
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3077.html">Alternative approach to Raw String issues</a>.
	(replacing <b>[</b> with <b>(</b>);
</li></ul>



<p>
</p><hr>
<h2 id="UD-literals">User-defined literals</h2>
C++ provides literals for a variety of built-in types (2.14 Literals):
<pre><b>
	123	// </b>int<b>
	1.2	// </b>double<b>
	1.2F	// </b>float<b>
	'a'	// </b>char<b>
	1ULL	// </b>unsigned long long<b>
	0xD0	// </b>hexadecimal unsigned<b>
	"as"	// </b>string<b>
</b></pre>
However, in C++98 there are no literals for user-defined types.
This can be a bother and also seen as a violation of the principle that user-defined types
should be supported as well as built-in types are.
In particular, people have requested:
<pre><b>
	"Hi!"s			// </b>string, not ``zero-terminated array of char''<b>
	1.2i			// </b>imaginary<b>
	123.4567891234df	// </b>decimal floating point (IBM)<b>
	101010111000101b	// </b>binary<b>
	123s			// </b>seconds<b>
	123.56km		// </b>not miles! (units)<b>
	1234567890123456789012345678901234567890x	// </b>extended-precision<b>
</b></pre>
C++11 supports ``user-defined literals'' through the notion of <i>literal operator</i>s that map literals
with a given suffix into a desired type. For example:
<pre><b>
	constexpr complex&lt;double&gt; operator "" i(long double d)	// </b>imaginary literal<b>
	{
		return {0,d};	// </b>complex<double> is a literal type<b>
	}

	std::string operator""s (const char* p, size_t n)	// </b>std::string literal<b>
	{
		return string(p,n);	// </b>requires free store allocation<b>
	}
</b></double></pre>
Note the use of <b>constexpr</b> to enable compile-time evaluation.
Given those, we can write
<pre><b>
	template&lt;class T&gt; void f(const T&amp;);
	f("Hello");	// </b>pass pointer to const char*<b>
	f("Hello"s);	// </b>pass (5-character) string object<b>
	f("Hello\n"s);	// </b>pass (6-character) string object<b>

	auto z = 2+1i;	// </b>complex<double>(2,1)<b>
</b></double></pre>
The basic (implementation) idea is that after parsing what could be a literal, the compiler always check for a suffix.
The user-defined literal mechanism simply allows the user to specify a new suffix and what is to be done with the
literal before it. It is not possible to redefine the meaning of a built-in literal suffix or augment the syntax of literals.
A literal operator can request to get its (preceding) literal passed ``cooked'' (with the value it would have had if the
new suffix hadn't been defined) or ``uncooked'' (as a string).
<p>
To get an ``uncooked'' string, simply request a single <b>const char*</b> argument:
</p><pre><b>
	Bignum operator"" x(const char* p)
	{
		return Bignum(p);
	}

	void f(Bignum);
	f(1234567890123456789012345678901234567890x);
</b></pre>
Here the C-style string <b>"1234567890123456789012345678901234567890"</b> is passed to <b>operator"" x()</b>.
Note that we did not explicitly put those digits into a string.
<p>
There are four kinds of literals that can be suffixed to make a user-defined literal
</p><ul>
<li>integer literal:
accepted by a literal operator taking a single <b>unsigned long long</b> or <b>const char*</b> argument.
</li><li>floating-point literal:
accepted by a literal operator taking a single <b>long double</b> or <b>const char*</b> argument.
</li><li>string literal:
accepted by a literal operator taking a pair of <b>(const char*, size_t)</b> arguments.
</li><li>character literal:
accepted by a literal operator taking a single <b>char</b> argument.
</li></ul>
Note that you cannot make a literal operator for a string literal that takes just a <b>const char*</b>
argument (and no size).
For example:
<pre><b>
	string operator"" S(const char* p);		// </b>warning: this will not work as expected<b>

	"one two"S;	// </b>error: no applicable literal operator<b>

</b></pre>
The rationale is that if we want to have ``a different kind of string'' we almost always want to know the number of characters
anyway.
<p>
Suffixes will tend to be short (e.g. <b>s</b> for string, <b>i</b> for imaginary, <b>m</b> for meter, and <b>x</b> for extended),
so different uses could easily clash. Use namespaces to prevent clashes:
</p><pre><b>
	namespace Numerics { 
		// ...
		class Bignum { /* </b>...<b> */ }; 
		namespace literals { 
			operator"" X(char const*); 
		} 
	} 

	using namespace Numerics::literals; 
</b></pre>


<p>
See also:
</p><ul>
<li>Standard 2.14.8 User-defined literals
</li><li>[N2378==07-0238] Ian McIntosh, Michael Wong, Raymond Mak, 
Robert Klarer, Jens Mauer, Alisdair Meredith, Bjarne Stroustrup, David 
Vandevoorde:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2378.pdf">User-defined Literals (aka. Extensible Literals (revision 3))</a>.
</li></ul>

<p>
</p><hr>
<h2 id="attributes">Attributes</h2>
``Attributes'' is a new standard syntax aimed at providing some order in the mess of facilities for
adding optional and/or vendor specific information into source code
(e.g. <b>__attribute__</b>, <b>__declspec</b>, and <b>#pragma</b>).
C++11 attributes differ from existing syntaxes by being applicable essentially everywhere in code
and always relating to the immediately preceding syntactic entity.
For example:
<pre><b>
	void f [[ noreturn ]] ()	// </b>f() will never return<b>
	{
		throw "error"; 	// OK
	}
	
	struct foo* f [[carries_dependency]] (int i);	// </b>hint to optimizer<b>
	int* g(int* x, int* y [[carries_dependency]]);
</b></pre>
As you can see, an attribute is placed within double square brackets: <b>[[ ... ]]</b>.
<b>noreturn</b> and <b>carries_dependency</b> are the two attributes defined in the standard.
<p>
There is a reasonable fear that attributes will be used to create language dialects.
The recommendation is to use attributes to only control things that do not affect the
meaning of a program but might help detect errors (e.g. <b>[[noreturn]]</b>) or help
optimizers (e.g. <b>[[carries_dependency]]</b>).
</p><p>
One planned use for attributes is improved support for OpenMP. For example:
</p><pre><b>
	for [[omp::parallel()]] (int i=0; i&lt;v.size(); ++i) {
		// ...
	}
</b></pre>
As shown, attributes can be qualified.
<p>
See also:
</p><ul>
<li>Standard: 7.6.1 Attribute syntax and semantics,
7.6.3-4 noreturn, carries_dependency
8 Declarators,
9 Classes,
10 Derived classes,
12.3.2 Conversion functions

</li><li>[N2418=07-027] Jens Maurer, Michael Wong:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2418.pdf">Towards support for attributes in C++ (Revision 3)</a>
</li></ul>


<p>
</p><hr>
<h2 id="lambda">Lambdas</h2>
A lambda expression is a mechanism for specifying a function object.
The primary use for a lambda is to specify a simple action to be performed by some function.
For example:
<pre> <b>
	vector&lt;int&gt; v = {50, -10, 20, -30};

	std::sort(v.begin(), v.end());	// </b>the default sort<b>
	// </b>now v should be { -30, -10, 20, 50 }<b>

	// </b>sort by absolute value:<b>
	std::sort(v.begin(), v.end(), [](int a, int b) { return abs(a)&lt;abs(b); });
	// </b>now v should be { -10, 20, -30, 50 }<b>
</b></pre>
The argument <b>[](int a, int b) { return abs(a)&lt;abs(b); }</b> is a "lambda" (or "lambda function" or "lambda expression"),
which specifies an operation that given two integer arguments <b>a</b> and <b>b</b> returns the result of comparing their
absolute values.
<p>
A lambda expression can access local variables in the scope in which it is used. For example:
</p><pre><b>
	void f(vector&lt;Record&gt;&amp; v)
	{
		vector&lt;int&gt; indices(v.size());
		int count = 0;
		generate(indices.begin(),indices.end(),[&amp;count](){ return count++; });

		// </b>sort indices in the order determined by the name field of the records:<b>
		std::sort(indices.begin(), indices.end(), [&amp;](int a, int b) { return v[a].name&lt;v[b].name; });
		// </b>...<b>
	}
</b></pre>
Some consider this "really neat!"; others see it as a way to write dangerously obscure code.
IMO, both are right.
<p>
The <b>[&amp;]</b> is a "capture list" specifying that local names used will be passed by reference. 
We could have said that we wanted to "capture" only <b>v</b>, we could have said so: <b>[&amp;v]</b>.
Had we wanted to pass <b>v</b> by value, we could have said so: <b>[=v]</b>.
Capture nothing is <b>[]</b>, capture all by references is <b>[&amp;]</b>,  and capture all by value is <b>[=]</b>.
</p><p>
If an action is neither common nor simple, I recommend using a named function object or function.
For example, the example above could have been written:
</p><pre><b>
	void f(vector&lt;Record&gt;&amp; v)
	{
		vector&lt;int&gt; indices(v.size());
		int count = 0;
		generate(indices.begin(),indices.end(),[&amp;](){ return ++count; });

		struct Cmp_names {
			const vector&lt;Record&gt;&amp; vr;
			Cmp_names(const vector&lt;Record&gt;&amp; r) :vr(r) { }
			bool operator()(int a, int b) const { return vr[a].name&lt;vr[b].name; }
		};

		// </b>sort indices in the order determined by the name field of the records:<b>
		std::sort(indices.begin(), indices.end(), Cmp_names(v));
		// </b>...<b>
	}
</b></pre>
For a tiny function, such as this Record name field comparison, the 
function object notation is verbose, though the generated code
is likely to be identical. In C++98, such function objects had to be 
non-local to be used as template argument; in C++11
<a href="#local-types">this is no longer necessary</a>.
<p>
To specify a lambda you must provide
</p><ul>
<li>its capture list: the list of variables it can use (in addition to its arguments),
if any (<b>[&amp;]</b> meaning "all local variables passed by reference" in the Record comparison example).
If no names needs to be captured, a lambda starts with plain <b>[]</b>.
</li><li>(optionally) its arguments and their types (e.g, <b>(int a, int b)</b>)
</li><li>The action to be performed as a block (e.g., <b>{ return v[a].name&lt;v[b].name; }</b>).
</li><li>(optionally) the return type using the
<a href="#suffix-return">new suffix return type syntax</a>; but typically we just deduce the return type from the return statement.
If no value is returned <b>void</b> is deduced.
</li></ul>

See also:
<ul>
<li> Standard 5.1.2 Lambda expressions
</li><li>[N1968=06-0038] Jeremiah Willcock, Jaakko Jarvi, Doug Gregor, Bjarne Stroustrup, and Andrew Lumsdaine: 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.htm">Lambda expressions and closures for C++</a>
(original proposal with a different syntax)
</li><li>[N2550=08-0060] Jaakko Jarvi, John Freeman, and Lawrence Crowl:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2550.pdf">Lambda Expressions and Closures: Wording for Monomorphic Lambdas (Revision 4)</a> (final proposal).
</li><li>[N2859=09-0049] Daveed Vandevoorde:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2859.pdf">New wording for C++0x Lambdas</a>.
</li></ul>




<p>
</p><hr>
<h2 id="local-types">Local types as template arguments</h2>
In C++98, local and unnamed types could not be used as template arguments.
This could be a burden, so C++11 lifts the restriction:
<pre><b>
	void f(vector&lt;X&gt;&amp; v)
	{
		struct Less {
			bool operator()(const X&amp; a, const X&amp; b) { return a.v&lt;b.v; }
		};
		sort(v.begin(), v.end(), Less());	// </b>C++98: error: Less is local<b>
							// </b>C++11: ok<b>
	}
</b></pre>
In C++11, we also have the alternative of using a
<a href="#lambda">lambda expression</a>:
<pre><b>
	void f(vector&lt;X&gt;&amp; v)
	{
	 	sort(v.begin(), v.end(), 
		      [] (const X&amp; a, const X&amp; b) { return a.v&lt;b.v; }); // </b>C++11 <b>
	}
</b></pre>
It is worth remembering that naming action can be quite useful for documentation and an encouragement to
good design. Also, non-local (necessarily named) entities can be reused.
<p>
C++11 also allows values of unnamed types to be used as template arguments:
</p><pre><b>
	template&lt;typename T&gt; void foo(T const&amp; t){}
	enum X { x };
	enum { y };

	int main()
	{
		foo(x);		// </b>C++98: ok; C++11: ok<b>
		foo(y);		// </b>C++98: error; C++11: ok<b>
		enum Z { z };
		foo(z);		// </b>C++98: error; C++11: ok<b> 
	}
</b></pre>
See also:
<ul>
<li>Standard: Not yet: CWG issue 757
</li><li>[N2402=07-0262] Anthony Williams:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2402.pdf">Names, Linkage, and Templates (rev 2)</a>.
</li><li>[N2657] John Spicer:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2657.htm">Local and Unnamed Types as Template Arguments</a>.
</li></ul>


<p>
</p><hr>
<h2 id="noexcept">noexcept -- preventing exception propagation</h2>
If a function cannot throw an exception or if the program isn't written to handle exceptions thrown by a
function, that function can be declared <b>noexcept</b>. For example:
<pre><b>
	extern "C" double sqrt(double) noexcept;	// </b>will never throw<b>

	vector&lt;double&gt; my_computation(const vector&lt;double&gt;&amp; v) noexcept // </b>I'm not prepared to handle memory exhaustion<b>
	{
		vector&lt;double&gt; res(v.size());	// </b>might throw<b>
		for(int i; i&lt;v.size(); ++i) res[i] = sqrt(v[i]);
		return res;
	}
</b></pre>
If a function declared <b>noexcept</b> throws (so that the exception tries to escape,
the <b>noexcept</b> function) the program is terminated (by a call to <b>terminate()</b>).
The call of <b>terminate()</b> cannot rely on objects being in well-defined states (i.e. there is no
guarantees that destructors have been invoked, no guaranteed stack unwinding, and no possibility for
resuming the program as if no problem had been encountered). This is deliberate and makes <b>noexcept</b>
a simple, crude, and very efficient mechanism (much more efficient than the old dynamic <b>throw()</b>
mechanism).
<p>
It is possibly to make a function conditionally <b>noexcept</b>.
For example, an algorithm can be specified to be <b>noexcept</b>
if (and only if) the operations it uses on a template argument are <b>noexcept</b>:
</p><pre><b>
	template&lt;class T&gt;
	void do_f(vector&lt;T&gt;&amp; v) noexcept(noexcept(f(v.at(0)))) // </b>can throw if f(v.at(0)) can<b>
	{
		for(int i; i&lt;v.size(); ++i)
			v.at(i) = f(v.at(i));
	}
</b></pre>
Here, I first use <b>noexcept</b> as an operator: <b>noexcept(f(v.at(0)))</b> is true if <b>f(v.at(0))</b>
can't throw, that is if the <b>f()</b> and <b>at()</b> used are <b>noexcept</b>.
<p>
The <b>noexcept()</b> operator is a constant expression and does not evaluate its operand.
</p><p>
The general form of a <b>noexcept</b> declaration is <b>noexcept(expression)</b> and ``plain <b>noexcept</b>''
is simply a shorthand for <b>noexcept(true)</b>. All declarations of a function must have compatible
<b>noexcept</b> specifications.
</p><p>
A destructor shouldn't throw;
a generated destructor is implicitly <b>noexcept</b> (independently of what code is in its body)
if all of the members of its class have <b>noexcept</b> destructors. 
</p><p>
It is typically a bad idea to have a move operation throw, so declare those <b>noexcept</b> wherever possible.
A generated copy or move operation is implicitly <b>noexcept</b> if all of the copy or move operations it uses
on members of its class have <b>noexcept</b> destructors. 
</p><p>
<b>noexcept</b> is widely and systematically used in the standard library to improve performance
and clarify requirements.

See also:
</p><ul>
<li>Standard: 15.4 Exception specifications [except.spec].
</li><li>Standard: 5.3.7 noexcept operator [expr.unary.noexcept].
</li><li>[N3103==10-0093] D. Kohlbrenner, D. Svoboda, and A. Wesie: Security impact of noexcept.
	(Noexcept <b>must</b> terminate, as it does).
</li><li>[N3167==10-0157] David Svoboda:
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3205.htm">Delete operators default to noexcept</a><a>.
</a></li><li><a>[N3204==10-0194] Jens Maurer:
	</a><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3204.htm">Deducing "noexcept" for destructors</a>
</li><li>[N3050==10-0040] D. Abrahams, R. Sharoni, and D. Gregor:
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3050.html">Allowing Move Constructors to Throw (Rev. 1)</a>.		
</li></ul>




<p>
</p><hr>
<h2 id="align">alignment</h2>
Occasionally, especially when we are writing code that manipulate raw memory,
we need to specify a desired alignment for some allocation.
For example:
<pre><b>
	alignas(double) unsigned char c[1024];	 // </b>array of characters, suitably aligned for doubles<b>
	alignas(16) char[100];			// </b>align on 16 byte boundary<b>
</b></pre>
There is also an
<b>alignof</b> operator that returns the alignment of its argument (which must be a type).
For example
<pre><b>
	constexpr int n = alignof(int);		// </b>ints are aligned on n byte boundaries<b>
</b></pre>

<p>
See also:
</p><ul>
<li>Standard: 5.3.6 Alignof [expr.alignof]
</li><li>Standard: 7.6.2 Alignment specifier [dcl.align]
</li><li>[N3093==10-0083] Lawrence Crowl:
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3093.html">C and C++ Alignment Compatibility</a>.
	Aligning the proposal to C's later proposal.
</li><li>[N1877==05-0137] Attila (Farkas) Fehr:
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1877.pdf">Adding Alignment Support to the C++ Programming Language</a>.
	The original proposal.
</li></ul>


<p>
</p><hr>
<h2 id="override">Override controls: override</h2>
No special keyword or annotation is needed for a function in a derived class to override a function in
a base class. For example:
<pre><b>
	struct B {
		virtual void f();
		virtual void g() const;
		virtual void h(char);
		void k();	// </b>not virtual<b>
	};

	struct D : B {
		void f();	// </b>overrides B::f()<b>
		void g();	// </b>doesn't override B::g() (wrong type)<b>
		virtual void h(char);	// </b>overrides B::h()<b>
		void k();	// </b>doesn't override B::k() (B::k() is not virtual)<b>
	};
</b></pre>
This can cause confusion (what did the programmer mean?),
and problems if a compiler doesn't warn against suspicious code.
For example,
<ul>
<li>Did the programmer mean to override <b>B::g()</b>?
	(almost certainly yes).
</li><li>Did the programming mean to override <b>B::h(char)</b>?
	(probably not because of the redundant explicit <b>virtual</b>).
</li><li>Did the programmer mean to override <b>B::k()</b>?
	(probably, but that's not possible).
</li></ul>
To allow the programmer to be more explicit about overriding, we now have the "contextual keyword" <b>override</b>:
<pre><b>
	struct D : B {
		void f() override;	// </b>OK: overrides B::f()<b>
		void g() override;	// </b>error: wrong type<b>
		virtual void h(char);	// </b>overrides B::h(); likely warning<b>
		void k() override;	// </b>error: B::k() is not virtual<b>
	};
</b></pre>
A declaration marked <b>override</b> is only valid if there is a function to override.
The problem with <b>h()</b> is not guaranteed to be caught
(because it is not an error according to the language definition)
but it is easily diagnosed.
<p>
<b>override</b> is only a <i>contextual</i> keyword, so you can still use it as an identifier:
</p><pre><b>
int override = 7;	// </b>not recommended<b>
</b></pre>
See also:
<ul>
<li>Standard: 10 Derived classes [class.derived] [9]
</li><li> Standard: 10.3 Virtual functions [class.virtual]
</li><li>[N3234==11-0004] Ville Voutilainen:
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/">Remove explicit from class-head</a>. 	
</li><li>[N3151==10-0141] Ville Voutilainen:
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3151.html">Keywords for override control</a>.
	Earlier, more elaborate design.
</li><li>[N3163==10-0153] Herb Sutter:
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3163.pdf">Override Control Using Contextual Keywords</a><a>.
	Alternative earlier more elaborate design.
</a></li><li><a>[N2852==09-0042] V. Voutilainen, A. Meredith, J. Maurer, and C. Uzdavinis:
	</a><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2852.html">Explicit Virtual Overrides</a>.
 	Earlier design based on <a href="#attributes">attributes</a>.
</li><li>[N1827==05-0087] C. Uzdavinis and A. Meredith:
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1827.htm">An Explicit Override Syntax for C++</a>.
	The original proposal.
</li></ul>


<p>
</p><hr>
<h2 id="final">Override controls: final</h2>
Sometimes, a programmer wants to prevent a virtual function from being overridden.
This can be achieved by adding the specifier <b>final</b>.
For example:
<pre><b>
	struct B {
		virtual void f() const final;	// </b>do not override<b>
		virtual void g();
	};

	struct D : B {
		void f() const; 	// </b>error: D::f attempts to override final B::f<b>
		void g();		// </b>OK<b>
	};
</b></pre>
There are legitimate reasons for wanting to prevent overriding, but I'm afraid that most examples I have
been shown to demonstrate the need for <b>final</b> have been based on mistaken assumptions on how
expensive <b>virtual</b> functions are (usually based on experience with other languages).
So, if you feel the urge to add a <b>final</b> specifier, please double check that the reason is logical: 
Would semantic errors be likely if someone defined a class that overwrote that virtual function?
Adding <b>final</b> closes the possibility of a future user of the class might provide a better implementation
of the function for some class you haven't thought of.
If you don't want to keep that option open,
why did you define the function to be <b>virtual</b> in the first place?
Most reasonable answers to that question that I have encountered have been along the lines:
This is a fundamental function in a framework that the framework builders needed to override but isn't
safe for general users to override.
My bias is to be suspicious towards such claims.
<p>
If it is performance (inlining) you want or you simply never want to override,
it is typically better not to define a function to be <b>virtual</b> in the first place.
This is not Java.</p><p>
<b>final</b> is only a <i>contextual</i> keyword, so you can still use it as an identifier:
</p><pre><b>
int final = 7;	// </b>not recommended<b>
</b></pre>
<p>
See also:
</p><ul>
<li>Standard: 10 Derived classes [class.derived] [9]
</li><li>Standard: 10.3 Virtual functions [class.virtual]
</li></ul>



<p>
</p><hr>
<h2 id="C99">C99 features</h2>
To preserve a high degree of compatibility,
a few minor changes to the language were introduced in collaboration with the C standards committee:
<ul>
<li><a href="#long-long">long long</a>.
</li><li><a href="#extended-int">Extended integral types</a> (i.e. rules for optional longer int types).
</li><li>UCN changes [N2170==07-0030] ``lift the prohibitions on control
 and basic source universal character names within character and string 
literals.''
</li><li>concatenation of narrow/wide strings.
</li><li> <i><b>Not</b></i> VLAs (Variable Length Arrays; thank heaven for small mercies).
</li></ul>
Some extensions of the preprocessing rules were added:
<ul>
<li><b>__func__ </b> a macro that expands to the name of the lexically current function
</li><li><b>__STDC_HOSTED__</b> 
</li><li><b>_Pragma</b>:	<b>_Pragma( X )</b> expands to <b>#pragma X</b>
</li><li>vararg macros  (overloading of macros with different number of arguments)
<pre><b>
	#define report(test, ...) ((test)?puts(#test):printf(_ _VA_ARGS_ _))
</b></pre>
</li><li>empty macro arguments
</li></ul>
A lot of standard library facilities were inherited from C99 
(essentially all changes to the C99 library from its C89 predecessor):
<p>
See:
</p><ul>
<li> Standard: 16.3 Macro replacement.
</li><li>[N1568=04-0008] P.J. Plauger:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1568.htm">PROPOSED ADDITIONS TO TR-1 TO IMPROVE COMPATIBILITY WITH C99</a>.


</li></ul>



<p>
</p><hr>
<h2 id="extended-int">Extended integer types</h2>
There are a set of rules for how an extended (precision) integer type should behave if one exists.
<p>
See
</p><ul>
<li>[06-0058==N1988] J. Stephen Adamczyk:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1988.pdf">Adding extended integer types to C++ (Revision 1)</a>.
</li></ul>



<p>
</p><hr>
<h2 id="dynamic-init">Dynamic Initialization and Destruction with Concurrency</h2>
Sorry, I have not had time to write this entry. See
<p>
</p><ul>
<li>[N2660 = 08-0170] Lawrence Crowl:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm">Dynamic Initialization and Destruction with Concurrency</a> (Final proposal).
</li></ul>





<p>
</p><hr>
<h2 id="thread-local">thread-local storage (<b>thread_local</b>)</h2>
Sorry, I have not had time to write this entry. See
<p>
</p><ul>
<li>[N2659 = 08-0169] Lawrence Crowl:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm">Thread-Local Storage</a> (Final proposal).
</li></ul>





<p>
</p><hr>
<h2 id="unicode">Unicode characters</h2>
Sorry, I have not had time to write this entry. Please come back later.
<p>
</p><ul>
<li>?
</li></ul>



<p>
</p><hr>
<h2 id="rethrow">Copying and rethrowing exceptions</h2>
How do you catch an exception and then rethrow it on another thread? 
Use a bit of library magic as described in the standard 18.8.5 Exception Propagation:
<ul>
<li><b>exception_ptr current_exception();</b>
<i>Returns: An exception_ptr object that refers to the currently handled
 exception (15.3) or a copy of the currently handled exception,
or a null exception_ptr object if no exception is being handled. The 
referenced object shall remain valid at least as long as there is 
an exception_ptr object that refers to it.  ... </i>
</li><li><b>void rethrow_exception(exception_ptr p);</b>
</li><li><b>template&lt;class E&gt; exception_ptr copy_exception(E e);</b> <i>Effects: as if</i>
<pre><b>
	try {
		throw e;
	} catch(...) {
		return current_exception();
	}
</b></pre>
This is particularly useful for <a href="#std-future">transmitting an exception from one thread to another</a>
</li></ul>


<p>
</p><hr>
<h2 id="extern-templates">Extern templates</h2>
A template specialization can be explicitly declared as a way to suppress multiple instantiations.
For example:
<pre> <b>
	#include "MyVector.h"

	extern template class MyVector&lt;int&gt;; // </b>Suppresses implicit instantiation below --<b>
					// </b>MyVector&lt;int&gt; will be explicitly instantiated elsewhere<b>

	void foo(MyVector&lt;int&gt;&amp; v)
	{
		// </b>use the vector in here<b>
	}
</b></pre>
The ``elsewhere'' might look something like this:
<pre><b>
	#include "MyVector.h"

	template class MyVector&lt;int&gt;; // </b>Make MyVector<int> available to clients (e.g., of the shared library)<b>
</b></int></pre>
This is basically a way of avoiding significant redundant work by the compiler and linker.
<p>
See
</p><ul>
<li> Standard 14.7.2 Explicit instantiation
</li><li>[N1448==03-0031] Mat Marcus and Gabriel Dos Reis:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1448.pdf">Controlling Implicit Template Instantiation</a>.
</li></ul>


<p>
</p><hr>
<h2 id="inline-namespace">Inline namespace</h2>
The <b>inline namespace</b> mechanism is intended to support library evolution by providing a mechanism
that support a form of versioning.
Consider:
<pre><b>
	// </b>file V99.h:<b>
	inline namespace V99 {
		void f(int);	//</b> does something better than the V98 version<b>
		void f(double);	//</b> new feature<b>
		// </b>...<b>
	}

	// </b>file V98.h:<b>
	namespace V98 {
		void f(int);	// </b>does something<b>
		// </b>...<b>
	}

	// </b>file Mine.h:<b>
	namespace Mine {
	#include "V99.h"
	#include "V98.h"
	}
</b></pre>
We here have a namespace <b>Mine</b> with both the latest release (<b>V99</b>) and the previous one (<b>V98</b>).
If you want to be specific, you can:
<pre><b>
	#include "Mine.h"
	using namespace Mine;
	// </b>...<b>
	V98::f(1);	// </b>old version<b>
	V99::f(1);	// </b>new version<b>
	f(1);		// </b>default version<b>
</b></pre>
The point is that the <b>inline</b> specifier makes the declarations from the nested namespace appear
exactly as if they had been declared in the enclosing namespace.
<p>
This is a very ``static'' and implementer-oriented facility in that the <b>inline</b> specifier has
to be placed by the designer of the namespaces -- thus making the choice for all users.
It is not possible for a user of <b>Mine</b> to say ``I want the default to be <b>V98</b> rather than <b>V99</b>.''

</p><p>
See
</p><ul>
<li> Standard 7.3.1 Namespace definition [7]-[9].
</li></ul>


<p>
</p><hr>
<h2 id="explicit-convertion">Explicit conversion operators</h2>
C++98 provides implicit and explicit constructors; that is, the conversion defined by a constructor declared <b>explicit</b>
can be used only for explicit conversions whereas other constructors can be used for implicit conversions also.
For example:
<pre>	struct S { S(int); };	// "ordinary constructor" defines implicit conversion
	S s1(1);		// ok
	S s2 = 1;	// ok
	void f(S);
	f(1);		// ok (but that's often a bad surprise -- what if S was vector?)

	struct E { explicit E(int); };	// explicit constructor
	E e1(1);		// ok
	E e2 = 1;	// error (but that's often a surprise)
	void f(E);
	f(1);		// error (protects against surprises -- e.g. std::vector's constructor from int is explicit)

</pre>
However, a constructor is not the only mechanism for defining a conversion.
If we can't modify a class, we can define a conversion operator from a different class. For example:
<pre>	struct S { S(int) { } /* ... */ };

	struct SS {
		int m;
		SS(int x) :m(x) { }
		operator S() { return S(m); }  // because S don't have S(SS); non-intrusive
	};

	SS ss(1);
	S s1 = ss;	// ok; like an implicit constructor
	S s2(ss);	// ok ; like an implicit constructor
	void f(S);
	f(ss);		// ok; like an implicit constructor
</pre>
Unfortunately, there is no <b>explicit</b> conversion operators (because there are far fewer problematic examples).
C++11 deals with that oversight by allowing conversion operators to be <b>explicit</b>. For example:
<pre>	struct S { S(int) { } };

	struct SS {
		int m;
		SS(int x) :m(x) { }
		explicit operator S() { return S(m); }  // because S don't have S(SS)
	};

	SS ss(1);
	S s1 = ss;	// error; like an explicit constructor
	S s2(ss);	// ok ; like an explicit constructor
	void f(S); 
	f(ss);		// error; like an explicit constructor

</pre>
See also:
<ul>
<li>Standard: 12.3 Conversions
</li><li>[N2333=07-0193] Lois Goldthwaite, Michael Wong, and Jens Maurer:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2333.html">Explicit Conversion Operator (Revision 1)</a>.
</li></ul>




<p>
</p><hr>
<h2 id="algorithms">Algorithms improvements</h2>
The standard library algorithms are improved partly by simple addition of new algorithms,
partly by improved implementations made possible by new language features, and
partly by new language features enabling easier use:
<ul>
<li><i>New algorithms</i>:
<pre><b>
	bool all_of(Iter first, Iter last, Pred pred);
	bool any_of(Iter first, Iter last, Pred pred);
	bool none_of(Iter first, Iter last, Pred pred);

	Iter find_if_not(Iter first, Iter last, Pred pred);

	OutIter copy_if(InIter first, InIter last, OutIter result, Pred pred);
	OutIter copy_n(InIter first, InIter::difference_type n, OutIter result);

	OutIter move(InIter first, InIter last, OutIter result);
	OutIter move_backward(InIter first, InIter last, OutIter result);

	pair&lt;OutIter1, OutIter2&gt; partition_copy(InIter first, InIter last, OutIter1 out_true, OutIter2 out_false, Pred pred);
	Iter partition_point(Iter first, Iter last, Pred pred);

	RAIter partial_sort_copy(InIter first, InIter last, RAIter result_first, RAIter result_last);
	RAIter partial_sort_copy(InIter first, InIter last, RAIter result_first, RAIter result_last, Compare comp);
	bool is_sorted(Iter first, Iter last);
	bool is_sorted(Iter first, Iter last, Compare comp);
	Iter is_sorted_until(Iter first, Iter last);
	Iter is_sorted_until(Iter first, Iter last, Compare comp);

	bool is_heap(Iter first, Iter last);
	bool is_heap(Iter first, Iter last, Compare comp);
	Iter is_heap_until(Iter first, Iter last);
	Iter is_heap_until(Iter first, Iter last, Compare comp);

	T min(initializer_list&lt;T&gt; t);
	T min(initializer_list&lt;T&gt; t, Compare comp);
	T max(initializer_list&lt;T&gt; t);
	T max(initializer_list&lt;T&gt; t, Compare comp);
	pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b);
	pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
	pair&lt;const T&amp;, const T&amp;&gt; minmax(initializer_list&lt;T&gt; t);
	pair&lt;const T&amp;, const T&amp;&gt; minmax(initializer_list&lt;T&gt; t, Compare comp);
	pair&lt;Iter, Iter&gt; minmax_element(Iter first, Iter last);
	pair&lt;Iter, Iter&gt; minmax_element(Iter first, Iter last, Compare comp);

	void iota(Iter first, Iter last, T value);	//</b> For each element 
referred to by the iterator i in the range [first,last), assigns *i = 
value and increments value as if by ++value<b>
</b></pre>
</li></ul>
<ul>
<li><i>Effects of move</i>:
Moving can be much more efficient than copying (see <a href="#rval">Move semantics</a>).
For example, move-based std::sort() and std::set::insert() has been measured to be 15 times faster than copy based versions.
This is less impressive than it sounds because such standard library operations for standard library types,
such as <b>string</b> and <b>vector</b>,
are usually hand-optimized to gain the
effects of moving through techniques such as replacing copies with optimized swaps. 
However, if <i>your</i> type has a move operation, you gain the performance benefits automatically from the standard algorithms.
<p>
Consider also that the use of moves allows simple and efficient sort (and other algorithms)
of containers of ``smart'' pointers,
especially
<a href="#std-unique_ptr">unique_ptr</a>:
</p><pre><b>
	template&lt;class P&gt; struct Cmp&lt;P&gt; {	// </b>compare *P values<b>
		bool operator() (P a, P b) const { return *a&lt;*b; }
	}

	vector&lt;std::unique_ptr&lt;Big&gt;&gt; vb;
	// </b>fill vb with unique_ptr's to Big objects<b>

	sort(vb.begin(),vb.end(),Cmp&lt;Big&gt;());	// </b>don't try that with an auto_ptr<b>
</b></pre>
</li><li><i>Use of lambdas</i>:
For ages, people have complained about having to write functions or (better) function objects for use as operations,
such as <b>Cmp&lt;T&gt;</b> above,
for standard library (and other) algorithms.
This was especially painful to do if you wrote large functions (don't) because in C++98 you could not define a
local function object to use as an argument; <a href="#local-types">now you can</a>.
However, <a href="#lambda">lambdas</a> allows us to define operations ``inline:''
<pre><b>
	sort(vb.begin(),vb.end(),[](unique_ptr&lt;Big&gt; a, unique_ptr&lt;Big&gt; b) { return *a&lt;*b; });
</b></pre>
I expect lambdas to be a bit overused initially (like all powerful mechanisms).
</li><li><i>Use of initializer lists</i>:
Sometimes, <a href="#init-list">initializer lists</a> come in handy as arguments.
For example, assuming <b>string</b> variables and <b>Nocase</b> being a case-insensitive comparison:
<pre><b>
	auto x = max({x,y,z},Nocase());
</b></pre>
</li></ul>


See also:
<ul>
<li>25 Algorithms library [algorithms]
</li><li>26.7 Generalized numeric operations [numeric.ops]
</li><li>Howard E. Hinnant, Peter Dimov, and Dave Abrahams:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm">A Proposal to Add Move Semantics Support to the C++ Language</a>.
N1377=02-0035.
</li></ul>

<p>
</p><hr>
<h2 id="containers">Container improvements</h2>
Given the new language features and a decade's worth of experience, what has happened to the 
standard containers?
First, of course we got a few new ones:
<a href="#std-array">array</a> (a fixed-sized container),
<a href="#std-forward_list">forward_list</a> (a singly-linked list),
and
<a href="#std-unordered">unordered containers</a> (the hash tables).
Next, new features, such as
<a href="#init-list">initializer lists</a>,
<a href="#rval">rvalue references</a>,
<a href="#variadic-templates">variadic templates</a>, and
<a href="#constexpr">constexpr</a> were put to use.
Consider <b>std::vector</b>.
<p>
</p><ul>
<li><i>Initializer lists</i>:
The most visible improvement is the use of initializer-list constructors to allow a container
to take an initializer list as its argument:
<pre><b>
	vector&lt;string&gt; vs = { "Hello", ", ", "World!", "\n" };
	for (auto s : vs ) cout &lt;&lt; s;
</b></pre>
</li><li><i>Move operators</i>:
Containers now have move constructors and move assignments (in addition to the traditional copy operations).
The most important implication of this is that we can efficiently return a container from a function:
<pre><b>
	vector&lt;int&gt; make_random(int n)
	{
		vector&lt;int&gt; ref(n);
		for(auto&amp; x : ref) x = rand_int(0,255);	// </b>some random number generator<b>
		return ref;
	}

	vector&lt;int&gt; v = make_random(10000);
	for (auto x : make_random(1000000)) cout &lt;&lt; x &lt;&lt; '\n';
</b></pre>
The point here is that no vectors are copied.
Rewrite this to return a free-store-allocated vector and you have to deal with memory management.
Rewrite this to pass the vector to be filled as an argument to <b>make_random()</b> and you
have a far less obvious code (plus an added opportunity for making an error).
</li><li><i>Improved push operations</i>:
My favorite container operation is <b>push_back()</b> that allows a container to grow gracefully:
<pre><b>
	vector&lt;pair&lt;string,int&gt;&gt; vp;
	string s;
	int i;
	while(cin&gt;&gt;s&gt;&gt;i) vp.push_back({s,i});
</b></pre>
This will construct a <b>pair&lt;string,int&gt;</b> out of <b>s</b> and <b>i</b> and move it into <b>vp</b>.
Note ``move'' not ``copy;''
There is a <b>push_back</b> version that takes an
<a href="#rval">rvalue reference</a>
argument so that we can take advantage of
<b>string</b>'s move constructor.
Note also the use of the
<a href="#uniform-init">unified initializer syntax</a> to avoid verbosity.
</li><li><i>Emplace operations</i>:
The <b>push_back()</b> using a move constructor is far more efficient in important cases than the traditional
copy-based one, but in extreme cases we can go further.
Why copy/move anything? Why not make space in the vector and then construct the desired value in that space?
Operations that do that are called ``emplace'' (meaning ``putting in place'').
For example <b>emplace_back()</b>:
<pre><b>
	vector&lt;pair&lt;string,int&gt;&gt; vp;
	string s;
	int i;
	while(cin&gt;&gt;s&gt;&gt;i) vp.emplace_back(s,i);
</b></pre>
An emplace takes a
<a href="#variadic-templates">variadic template</a>
argument and uses that to construct an object of the desired type.
Whether the <b>emplace_back()</b> really is more efficient than the <b>push_back()</b> depends on the types involved
and the implementation (of the library and of variadic templates).
If you think it matters, measure.
Otherwise, choose based on aesthetics: <b>vp.push_back({s,i});</b> or <b>vp.emplace_back(s,i);</b>.
For now, I prefer the <b>push_back()</b> version, but that might change over time.
</li><li><a href="#scoped-allocator">Scoped allocators</a>:
Containers can now hold "real allocation objects (with state)" and use those to control
nested/scoped allocation (e.g. allocation of elements in a container)
</li></ul>
Obviously, the containers are not the only parts of the standard library that has benefitted from the new
language features. Consider:
<ul>
<li><i>Compile-time evaluation</i>:
<a href="#constexpr">constexpr</a>
is used to ensure compiler time evaluation in
<b><numeric_limits></numeric_limits></b>, 
<b>bitset</b>,
<b>duration</b>,
<b>char_traits</b>,
<a href="#std-array">array</a>,
atomic types,
random numbers,
<b>complex&lt;double&gt;</b>., etc. 
In some cases, it means improved performance;
in others (where there is no alternative to compile-time evaluation),
it means absence of messy low-level code and macros.
</li><li><i>Tuples</i>:
Tuples would not be possible without variadic templates.
</li></ul>




<p>
</p><hr>
<h2 id="scoped-allocator">Scoped allocators</h2>
For compactness of container objects and for simplicity, C++98 did not require containers to support allocators with state:
Allocator objects need not be stored in container objects.
This is still the default in C++11, but it is possible to use an allocator with state, say an allocator that holds a
pointer to an arena from which to allocate.
For example:
<pre><b>
	template&lt;class T&gt; class Simple_alloc {	// </b>C++98 style<b>
		// </b>no data<b>
		// </b>usual allocator stuff<b>
	};

	class Arena {
		void* p;
		int s;
	public:
		Arena(void* pp, int ss);
		// </b>allocate from p[0..ss-1]<b>
	};

	template&lt;class T&gt; struct My_alloc {
		Arena&amp; a;
		My_alloc(Arena&amp; aa) : a(aa) { }
		// </b>usual allocator stuff<b>
	};

	Arena my_arena1(new char[100000],100000);
	Arena my_arena2(new char[1000000],1000000);

	vector&lt;int&gt; v0;	// </b>allocate using default allocator<b>

	vector&lt;int,My_alloc&lt;int&gt;&gt; v1(My_alloc&lt;int&gt;{my_arena1});	// </b>allocate from my_arena1<b>

	vector&lt;int,My_alloc&lt;int&gt;&gt; v2(My_alloc&lt;int&gt;{my_arena2});	// </b>allocate from my_arena2<b>

	vector&lt;int,Simple_alloc&lt;int&gt;&gt; v3;	// </b>allocate using Simple_alloc<b>
</b></pre>
Typically, the verbosity would be alleviated by the use of typedefs.
<p>
It is not guaranteed that the default allocator and <b>Simple_alloc</b> takes up no space
in a vector object, but a bit of elegant template metaprogramming in the library implementation
can ensure that.
So, using an allocator type imposes a space overhead only if its objects actually has state (like <b>My_alloc</b>).
</p><p>
A rather sneaky problem can occur when using containers and user-defined allocators:
Should an element be in the same allocation area as its container?
For example, if you use <b>Your_allocator</b> for <b>Your_string</b> to allocate its elements
and I use <b>My_allocator</b> to allocate elements of <b>My_vector</b>
then which allocator should be used for string elements in <b>My_vector&lt;Your_allocator&gt;</b>? 
The solution is the ability to tell a container which allocator to pass to elements.
For example, assuming that I have an allocator <b>My_alloc</b>
and I want a <b>vector&lt;string&gt;</b>
that uses <b>My_alloc</b> for both the <b>vector</b> element
and <b>string</b> element allocations.
First, I must make a version of <b>string</b> that accepts
<b>My_alloc</b> objects:
</p><pre><b>
	using xstring = basic_string&lt;char, char_traits&lt;char&gt;, My_alloc&lt;char&gt;&gt;;	// </b>a string with my allocator<b>
</b></pre>
Then, I must make a version of <b>vector</b> that accepts those strings,
accepts a <b>My_alloc</b> object,
and passes that object on to the string:
<pre><b>
	using svec = vector&lt;xstring,scoped_allocator_adaptor&lt;My_alloc&lt;xstring&gt;&gt;&gt;;	
</b></pre>
Finally, we can make an allocator of type <b>My_alloc&lt;xstring&gt;</b>:
<pre><b>
	svec v(svec::allocator_type(My_alloc&lt;xstring&gt;{my_arena1}));
</b></pre>
Now <b>svec</b> is a <b>vector</b> of strings using <b>My_alloc</b> to allocate memory for strings.
What's new is that the standard library ``adaptor'' (''wrapper type'') <b>scoped_allocator_adaptor</b> is used
to indicate that string also should use <b>My_alloc</b>.
Note that the adaptor can (trivially) convert <b>My_alloc&lt;xstring&gt;</b> to the <b>My_alloc&lt;char&gt;</b> that <b>xstring</b> needs.
<p>
So, we have four alternatives:
</p><pre><b>
	// </b>vector and string use their own (the default) allocator:<b>
	using svec0 = vector&lt;string&gt;;
	svec0 v0;

	// </b>vector (only) uses My_alloc and string uses its own (the default) allocator:<b>
	using svec1 = vector&lt;string,My_alloc&lt;string&gt;&gt;;
	svec1 v1(My_alloc&lt;string&gt;{my_arena1});

	// </b>vector and string use My_alloc (as above):<b>
	using xstring = basic_string&lt;char, char_traits&lt;char&gt;, My_alloc&lt;char&gt;&gt;;
    	using svec2 = vector&lt;xstring,scoped_allocator_adaptor&lt;My_alloc&lt;xstring&gt;&gt;&gt;;
    	svec2 v2(scoped_allocator_adaptor&lt;My_alloc&lt;xstring&gt;&gt;{my_arena1});

	// </b>vector uses My_alloc and string uses My_string_alloc:<b>
	using xstring2 = basic_string&lt;char, char_traits&lt;char&gt;, My_string_alloc&lt;char&gt;&gt;;
	using svec3 = vector&lt;xstring2,scoped_allocator_adaptor&lt;My_alloc&lt;xstring&gt;, My_string_alloc&lt;char&gt;&gt;&gt;;	
	svec3 v3(scoped_allocator_adaptor&lt;My_alloc&lt;xstring2&gt;, My_string_alloc&lt;char&gt;&gt;{my_arena1,my_string_arena}); 
</b></pre>
Obviously, the first variant, <b>svec0</b>, will be by far the most common, but for systems with serious memory-related
performance constraints, the other versions (especially <b>svec2</b>) can be important.
A few typedefs would make that code a bit more readable, but it is good it is not something you have to
write every day.
The <b>scoped_allocator_adaptor2</b> is a variant of <b>scoped_allocator_adaptor</b> for the case where
the two non-default allocators differ.


<p>
See also:
</p><ul>
<li>Standard: 20.8.5 Scoped allocator adaptor [allocator.adaptor]
</li><li>Pablo Halpern:
<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2008/n2554.pdf">The Scoped Allocator Model (Rev 2)</a>.
 N2554=08-0064. 
</li></ul>



<p>
</p><hr>
<h2 id="std-array">std::array</h2>
The standard container <b>array</b> is a fixed-sized random-access sequence of elements defined in <b>&lt;array&gt;</b>.
It has no space overheads beyond what it needs to hold its elements,
it does not use free store,
it can be initialized with an initializer list,
it knows its size (number of elements),
and doesn't convert to a pointer unless you explicitly ask it to. 
In other words, it is very much like a built-in array without the problems.
<pre><b>
	array&lt;int,6&gt; a = { 1, 2, 3 };
	a[3]=4;
	int x = a[5];		// </b>x becomes 0 because default elements are zero initialized<b>
	int* p1 = a;		// </b>error: std::array doesn't implicitly convert to a pointer<b>
	int* p2 = a.data();	// </b>ok: get pointer to first element <b>
</b></pre>
Note that you can have zero-length <b>array</b>s but that you cannot deduce the length of an <b>array</b>
from an initializer list:
<pre><b>
	array&lt;int&gt; a3 = { 1, 2, 3 };	// </b>error: size unknown/missing<b>
	array&lt;int,0&gt; a0;		// </b>ok: no elements<b>
	int* p = a0.data();		// </b>unspecified; don't try it<b>
</b></pre>
The standard <b>array</b>'s features makes it attractive for embedded systems programming
(and similar constrained, performance-critical, or safety critical tasks).
It is a sequence container so it provides the usual member types and functions (just like <b>vector</b>):
<pre><b>
	template&lt;class C&gt; C::value_type sum(const C&amp; a)
	{
		return accumulate(a.begin(),a.end(),0);
	}

	array&lt;int,10&gt; a10;
	array&lt;double,1000&gt; a1000;
	vector&lt;int&gt; v;
	// </b>...<b>
	int x1 = sum(a10);
	double x2 = sum(a1000);
	int x3 = sum(v);

</b></pre>
Also, you don't get (potentially nasty) derived to base conversions:
<pre><b>
	struct Apple : Fruit { /* </b>...<b> */ };
	struct Pear : Fruit { /* </b>...<b> */ };

	void nasty(array&lt;Fruit*,10&gt;&amp; f)
	{
		f[7] = new Pear();
	};

	array&lt;Apple*,10&gt; apples;
	// </b>...<b>
	nasty(apples);	// </b>error: can't convert array&lt;Apple*,10&gt; to array&lt;Fruit*,10&gt;;<b>
</b></pre>
If that was allowed, <b>apples</b> would now contain a <b>Pear</b>.
<p>
See also:
</p><ul>
<li>Standard: 23.3.1 Class template array
</li></ul>


<p>
</p><hr>
<h2 id="std-forward_list">std::forward_list</h2>
The standard container <b>forward_list</b>, defined in <b>&lt;forward_list&gt;</b>, is basically a singly-linked list.
It supports forward iteration (only) and guarantees that elements don't move if you insert or erase one.
It occupies minimal space (an empty list is likely to be one word) and does not provide a <b>size()</b> operation
(so that it does not have to store a size member):
<pre><b>
	template &lt;ValueType T, Allocator Alloc = allocator&lt;T&gt; &gt;
		requires NothrowDestructible&lt;T&gt;
	class forward_list {
	public:
		// </b>the usual container stuff<b>
		// </b>no size()<b>
		// </b>no reverse iteration<b>
		// </b>no back() or push_back()<b>
	};
</b></pre>
<p>
See also:
</p><ul>
<li>Standard: 23.3.3 Class template forward_list
</li></ul>



<p>
</p><hr>
<h2 id="std-unordered">Unordered containers</h2>
A unordered container is a kind of hash table. C++11 offers four standard ones:
<ul>
<li>unordered_map
</li><li>unordered_set
</li><li>unordered_multimap
</li><li>unordered_multiset
</li></ul>
They should have been called <b>hash_map</b> etc., but there are so many incompatible uses of those names that
the committee had to choose new names and the <b>unordered_map</b>, etc. were the least bad we could find.
The "unordered" refers to one of the key differences between <b>map</b> and <b>unordered_map</b>:
When you iterate over a <b>map</b>
you do so in the order provided by its less-than comparison operator (by default <b>&lt;</b>) whereas the value type
of <b>unordered_map</b> is not required to have a less-than comparison operator and a hash table doesn't naturally
provide an order.
Conversely, the element type of a <b>map</b> is not required to have a hash function.
<p>
The basic idea is simply to use <b>unordered_map</b> as an optimized version of <b>map</b> where
optimization is possible and reasonable. For example:
</p><pre><b>
	map&lt;string,int&gt; m {
		{"Dijkstra",1972}, {"Scott",1976}, {"Wilkes",1967}, {"Hamming",1968}
	};
	m["Ritchie"] = 1983;
	for(auto x : m) cout &lt;&lt; '{' &lt;&lt; x.first &lt;&lt; ',' &lt;&lt; x.second &lt;&lt; '}';

	unordered_map&lt;string,int&gt; um {
		{"Dijkstra",1972}, {"Scott",1976}, {"Wilkes",1967}, {"Hamming",1968}
	};
	um["Ritchie"] = 1983;
	for(auto x : um) cout &lt;&lt; '{' &lt;&lt; x.first &lt;&lt; ',' &lt;&lt; x.second &lt;&lt; '}';
</b></pre>
The iterator over <b>m</b> will present the elements in alphabetical order; the iteration over <b>um</b>
will not (except through a freak accident).
Lookup is implemented very differently for <b>m</b> and <b>um</b>.
For <b>m</b> lookup involves log2(m.size()) less-than comparisons whereas for <b>um</b>
lookup involves a single call of a hash function and one or more equality operations.
For a few elements (say a few dozen), it is hard to tell which is faster.
For larger numbers of elements (e.g. thousands), lookup in an <b>unordered_map</b>
can be much faster than for a <b>map</b>.
<p>
More to come.
</p><p>
See also:
</p><ul>
<li>Standard: 23.5 Unordered associative containers.
</li></ul>




<p>
</p><hr>
<h2 id="std-tuple">std::tuple</h2>
The standard library <b>tuple</b> (an N-tuple) is a ordered sequence of N values where
N can be a constant from 0 to a large implementation-defined value, defined in <b>&lt;tuple&gt;</b>.
You can think of an tuple as an unnamed struct with members of the specified tuple element types.
In particular, the elements of a <b>tuple</b> is stored compactly; a tuple is not a linked structure.
<p>
The element types of a tuple can explicitly specified or be deduced (using <b>make_tuple()</b>)
and the elements can be access by (zero-based) index using <b>get()</b>:
</p><pre><b>
	tuple&lt;string,int&gt; t2("Kylling",123);

	auto t = make_tuple(string("Herring"),10, 1.23);	// </b>t will be of type tuple&lt;string,int,double&gt;<b>
	string s = get&lt;0&gt;(t);
	int x = get&lt;1&gt;(t);
	double d = get&lt;2&gt;(t);
</b></pre>
Tuples are used (directly of indirectly) whenever we want a heterogeneous list of elements at compile time
but do not want to define a named class to hold them.
For example, <b>tuple</b> is used internally in <a href="#std-function">std::function and std::bind</a> to
hold arguments.
<p>
The most frequently useful tuple is the 2-tuple; that is, a pair.
However, pair is directly supported in the standard library through <b>std::pair</b> (20.3.3 Pairs).
A <b>pair</b> can be used to initialize a <b>tuple</b>, but the opposite isn't the case.
</p><p>
The comparison operators (==, !=, &lt;, &lt;=, &gt;, and &gt;=) are defined for tuples of comparable element types.
</p><p>
See also:
</p><ul>
<li>Standard: 20.5.2 Class template tuple
</li><li>Variadic template paper
</li><li>Boost::tuple
</li></ul>

<p>
</p><hr>
<h2 id="type_traits">metaprogramming and type traits</h2>
Sorry. Come back later.

<p>
</p><hr>
<h2 id="std-function">std::function and std::bind</h2>
The <b>bind</b> and <b>function</b> standard function objects are defined in <b>&lt;functional&gt;</b>
(together with a lot of other function objects);
they are used to handle functions and function arguments.
<b>bind</b> is used to take a function (or a function object or anything you can invoke using the <b>(...)</b> syntax)
and produce a function object with one or more of the arguments of the argument function ``bound'' or rearranged.
For example:
<pre><b>
	int f(int,char,double);
	auto ff = bind(f,_1,'c',1.2);	// </b>deduce return type<b>
	int x = ff(7);			// </b>f(7,'c',1.2);<b>
</b></pre>
This binding of arguments is usually called ``Currying.''
The <b>_1</b> is a place-holder object indicating where the first argument of <b>ff</b> is to go when <b>f</b> is
called through <b>ff</b>.
The first argument is called <b>_1</b>, the second <b>_2</b>, and so on. For example:
<pre><b>
	int f(int,char,double);
	auto frev = bind(f,_3,_2,_1);	// </b>reverse argument order<b>
	int x = frev(1.2,'c',7);	// </b>f(7,'c',1.2);<b>
</b></pre>
Note how <a href="#auto">auto</a> saves us from having to specify the type of the result of <b>bind</b>.
<p>
It is not possible to just bind arguments for an overloaded function,
we have to explicitly state which version of an overloaded function we want to bind:
</p><pre><b>
	int g(int);
	double g(double);	// </b>g() is overloaded<b>

	auto g1 = bind(g,_1);				// </b>error: which g()?<b>
	auto g2 = bind((double(*)(double))g,_1);	// </b>ok (but ugly)<b>

</b></pre>
<b>bind()</b> comes in two variants: the one shown above and a "legacy" version where you explicitly specify the return type:
<pre><b>
	auto f2 = bind&lt;int&gt;(f,7,'c',_1);	// </b>explicit return type<b>
	int x = f2(1.2);			// </b>f(7,'c',1.2);<b>
</b></pre>
This second version was necessary and is widely used because the first (and for a user simplest)
version cannot be implemented in C++98.
<p>
<b>function</b> is a type that can hold a value of just about anything you can invoke using the <b>(...)</b> syntax.
In particular, the result of <b>bind</b> can be assigned to a <b>function</b>.
<b>function</b> is very simple to use. For example:
</p><pre><b>
	function&lt;float (int x, int y)&gt; f;	// </b>make a function object<b>

	struct int_div {			// </b>take something you can call using ()<b>
		float operator()(int x, int y) const { return ((float)x)/y; };
	};

	f = int_div();				// </b>assign<b>
	cout &lt;&lt; f(5, 3) &lt;&lt; endl;		// </b>call through the function object<b>
	std::accumulate(b,e,1,f);		// </b>passes beautifully<b>
</b></pre>
Member functions can be treated as free functions with an extra argument
<pre><b>
	struct X {
		int foo(int);
	};

	function&lt;int (X*, int)&gt; f;
	f = &amp;X::foo;		// </b>pointer to member<b>

	X x;
	int v = f(&amp;x, 5);	// </b>call X::foo() for x with 5<b>
	function&lt;int (int)&gt; ff = std::bind(f,&amp;x,_1);	// </b>first argument for f is &amp;x<b>
	v=ff(5); 		// </b>call x.foo(5)<b>
</b></pre>
<b>function</b>s are useful for callbacks, for passing operations as argument, etc.
It can be seen as a replacement for the C++98 standard library function objects
<b>mem_fun_t</b>, <b>pointer_to_unary_function</b>, etc.
Similarly, <b>bind()</b> can be seen as a replacement for <b>bind1()</b> and <b>bind2()</b>.
<p>
See also:
</p><ul>
<li>Standard: 20.7.12 Function template bind, 20.7.16.2 Class template function
</li><li>Herb Sutter:
<a href="http://www.ddj.com/article/printableArticle.jhtml;jsessionid=QQIFSNAIOYXN0QSNDLPSKHSCJUNN2JVN?articleID=184403746&amp;dept_url=/cpp/">Generalized Function Pointers</a>.
August 2003.
</li><li> Douglas Gregor:
<a href="http://www.boost.org/doc/libs/1_38_0/doc/html/function.html">Boost.Function</a>.
</li><li>Boost::bind
</li></ul>

<p>
</p><hr>
<h2 id="std-unique_ptr">unique_ptr</h2>
<ul>
<li>The <b>unique_ptr</b> (defined in <b>&lt;memory&gt;</b>) provides a semantics of strict ownership.
<ul>
<li>owns the object it holds a pointer to
</li><li>is not CopyConstructible, nor CopyAssignable;
however, it is MoveConstructible and MoveAssignable.
</li><li>stores a pointer to an object and deletes that object
using the associated deleter when it is itself destroyed (such as when leaving block scope (6.7)).
</li></ul>
</li><li>The uses of <b>unique_ptr</b> include
<ul>
<li>providing exception safety for dynamically allocated memory,
</li><li>Passing ownership of dynamically allocated memory to a function
</li><li>returning dynamically allocated memory from a function
</li><li>storing pointers in containers
</li></ul>
</li><li>"what <b>auto_ptr</b> should have been" (but that we couldn't write in C++98)
</li></ul>
<b>unique_ptr</b> relies critically on <a href="#rval">rvalue references</a> and move semantics.

<p>
Here is a conventional piece of exception unsafe code:
</p><pre><b>
	X* f()
	{
		X* p = new X;
		// </b>do something - maybe throw an exception<b>
		return p;
	}
</b></pre>
A solution is to hold the pointer to the object on the free store in a <b>unique_ptr</b>:
<pre><b>
	X* f()
	{
		unique_ptr&lt;X&gt; p(new X);		// </b>or {new X} but not = new X<b>
		// </b>do something - maybe throw an exception<b>
		return p.release();
	}
</b></pre>
Now, if an exception is thrown, the <b>unique_ptr</b> will (implicitly) destroy the object pointed to.
That's basic
<a href="http://www.stroustrup.com/bs_faq2.html#finally">RAII</a>.
However, unless we really need to return a built-in pointer,
we can do even better by returning a <b>unique_ptr</b>:
<pre><b>
	unique_ptr&lt;X&gt; f()
	{
		unique_ptr&lt;X&gt; p(new X);		// </b>or {new X} but not = new X<b>
		// </b>do something - maybe throw an exception<b>
		return p;	// </b>the ownership is transferred out of f()<b>
	}
</b></pre>
We can use this <b>f</b> like this:
<pre><b>
	void g()
	{
		unique_ptr&lt;X&gt; q = f();       // </b>move using move constructor<b>
		q-&gt;memfct(2);                // </b>use q<b>
		X x = *q;                    // </b>copy the object pointed to<b>
		// </b>...<b>
	}	// </b>q and the object it owns is destroyed on exit<b>
</b></pre>
The <b>unique_ptr</b> has "move semantics" so the initialization of <b>q</b> with the rvalue that is the result of the call
<b>f()</b> simply transfers ownership into <b>q</b>.
<p>
One of the uses of <b>unique_ptr</b> is as a pointer in a container, where we might have used a built-in pointer
except for exception safety problems (and to guarantee destruction of the pointed to elements):
</p><pre><b>
	vector&lt;unique_ptr&lt;string&gt;&gt; vs { new string{"Doug"}, new string{"Adams"} };
</b></pre>

<p>
<b>unique_ptr</b> is represented by a simple built-in pointer and the overhead of using one compared to a built-in pointer
are miniscule.
In particular, <b>unique_ptr</b> does not offer any form of dynamic checking.
</p><p>

See also
</p><ul>
<li>the C++ draft section 20.7.10
</li><li>Howard E. Hinnant: 
<a href="http://home.roadrunner.com/%7Ehinnant/unique_ptr03.html">unique_ptr Emulation for C++03 Compilers</a>.
</li></ul>



<p>
</p><hr>
<h2 id="std-shared_ptr">shared_ptr</h2>
A <b>shared_ptr</b> is used to represent shared ownership; that is, when two pieces of code needs access
to some data but neither has exclusive ownership (in the sense of being responsible for destroying the object).
A <b>shared_ptr</b> is a kind of counted pointer where the object pointed to is deleted when the use count goes to zero.
Here is a highly artificial example:
<pre>	void test()
	{
		shared_ptr&lt;int&gt; p1(new int);	// count is 1
		{
			shared_ptr&lt;int&gt; p2(p1);	// count is 2
			{
				shared_ptr&lt;int&gt; p3(p1);	// count is 3
			}	// count goes back down to 2
		} // count goes back down to 1
	}	// here the count goes to 0 and the int is deleted.

</pre>
A more realistic example would be pointers to nodes in a general graph where someone wanting to remove a pointer
to a node wouldn't know if anyone else held a pointer to that node. If a node can hold resources that
require an action by a destructor (e.g. a file handle so that a file needs to be closed when the node
is deleted).
You could consider <b>shared_ptr</b> to be for what you might consider plugging in a
<a href="#gc-abi">garbage collector</a> for, except that maybe you don't have enough garbage for that
to be economical, your execution environment doesn't allow that, or the resource managed is not just
memory (e.g. that file handle).
For example:
<pre>	struct Node {	// note: a Node may be pointed to from several other nodes.
		shared_ptr&lt;Node&gt; left;
		shared_ptr&lt;Node&gt; right;
		File_handle f;
		// ...
	};
</pre>
Here <b>Node</b>'s destructor (the implicitly generated destructor will do fine) deletes its sub-nodes;
that is, <b>left</b> and <b>right</b>'s destructors are invoked.
Since <b>left</b> is a <b>shared_ptr</b>,
the <b>Node</b> pointed to (if any) is deleted if <b>left</b> was the last pointer to it; <b>right</b>
is handled similarly and <b>f</b>'s destructor does whatever is required for <b>f</b>.
<p>
Note that you should not use a <b>shared_ptr</b> just to pass a pointer from one owner to another; that's
what <a href="#std-unique_ptr">unique_ptr</a> is for and <b>unique_ptr</b> does that cheaper and better.
If you have been using counted pointers as return values from factory functions and the like, consider
upgrading to <b>unique_ptr</b> rather than <b>shared_ptr</b>.
</p><p>
Please don't thoughtlessly replace pointers with <b>shared_ptr</b>s in an attempt to prevent memory leaks;
<b>shared_ptr</b>s are not a panacea nor are they without costs:
</p><ul>
<li>a circular linked structure of <b>shared_ptr</b>s
will cause a memory leak (you'll need some logical complication to break
the circle, e.g. using a <b>weak_ptr</b>),
</li><li>"shared ownership objects" tend to stay "live" for longer than scoped objects (thus causing
higher average resource usage),
</li><li>shared pointers in a multi-threaded environment can be expensive
(because of the need to avoid data races on the use count),
</li><li>a destructor for a shared object does not execute at a predictable time, and
</li><li>the algorithms/logic for the update of any shared object is easier to get wrong than for an object
that's not shared.
</li></ul>.
A <b>shared_ptr</b> represents
<i>shared ownership</i> but shared ownership isn't my ideal: It is better if an object has a definite
owner and a definite, predictable lifespan.
<p>
See also
</p><ul>
<li>the C++ draft: Shared_ptr (20.7.13.3)
</li></ul>

<p>
</p><hr>
<h2 id="std-weak_ptr">weak_ptr</h2>
Weak pointers are often explained as what you need to break loops in data structures managed using
<a href="#std-shared_ptr">shared_ptr</a>s.
I think it is better to think of a <b>weak_ptr</b> as a pointer to something that
<ol>
<li>you need access to (only) if it exists, and
</li><li>may get deleted (by someone else), and
</li><li>must have its destructor called after its last use (usually to delete anon-memory resource)
</li></ol>
Consider an implementation of the old "asteroid game".
All asteroids are owned by "the game" but each asteroids must keep track of neighboring asteroids and
handle collisions. A collision typically leads to the destruction of one or more asteroids.
Each asteroid must keep a list of other asteroids in its neighborhood.
Note that being on such a neighbor list should not keep an astroid "alive" (so a <b>shared_ptr</b>
would be inappropriate).
On the other hand, an asteroid must not be destroyed while another asteroid is looking at it
(e.g. to calculate the effect of a collision).
And obviously, an asteroids destructor must be called to release resources (such as a connection to
the graphics system).
What we need is a list of asteroids that <i>might</i> still be intact and a way of "getting hold of one <i>if</i> it exist"
for a while. A <b>weak_ptr</b> does just that:
<pre>	void owner()
	{
		// ...
		vector&lt;shared_ptr&lt;Asteroid&gt;&gt; va(100);
		for (int i=0; i&lt;va.size(); ++i) {
			// ... calculate neighbors for new asteroid ...
			va[i].reset(new Asteroid(weak_ptr&lt;Asteroid&gt;(va[neighbor]));
			launch(i);
		}
		// ...
	}
</pre>
<b>reset()</b> is the function to make a <b>shared_ptr</b> refer to a new object.
<p>
Obviously, I radically simplified "the owner" and gave each new <b>Asteroid</b> just one neighbor.
The key is that we give the Asteroid a <b>weak_ptr</b> to that neighbor.
The owner keeps a <b>shared_ptr</b> to represent the ownership that's shared whenever an <b>Asteroid</b>
is looking (but not otherwise).
The collision calculation for an <b>Asteroid</b> will look something like this:
</p><pre>	void collision(weak_ptr&lt;Asteroid&gt; p)
	{
		if (auto q = p.lock()) {	// p.lock returns a shared_ptr to p's object
			// ... that Asteroid still existed: calculate ...
		}
		else {
			// ... oops: that Asteroid has already been destroyed: just forget about it (delete the weak_ptr to it ...
		}
	}
</pre>
Note that even if the owner decides to shut down the game and deletes all <b>Asteroids</b>
(by destroying the <b>shared_ptr</b>s representing ownership)
every <b>Asteroid</b> that is in the middle of calculating a collision still finishes correctly
(because after the <b>p.lock()</b> it holds
a <b>shared_ptr</b> that won't just become invalid).
<p>
I expect to find <b>weak_ptr</b> use much rarer than "plain" <b>shared_ptr</b> use
and I hope that <b>unique_ptr</b> will become much more popular than <b>shared_ptr</b> use
because <b>unique_ptr</b>  represents a simpler (and more efficient) notion of ownership and (therefore) allows better local reasoning.
</p><p>
See also
</p><ul>
<li>the C++ draft: Weak_ptr (20.7.13.3)
</li></ul>


<p>
</p><hr>
<h2 id="gc-abi">Garbage collection ABI</h2>
Garbage collection (automatic recycling of unreferenced regions of memory) is optional in C++;
that is, a garbage collector is not a compulsory part of an implementation.
However, C++11 provides a definition of what a GC can do if one is used and an ABI (Application Binary Interface)
to help control its actions.
<p>
The rules for pointers and lifetimes are expressed in terms of  "safely derived pointer" (3.7.4.3);
roughly: "pointer to something allocated by new or to a sub-object thereof."
Here are some examples of "not safely derived pointers" aka "disguised pointers"
aka what not to do in a program you want to be considered well behaved and 
comprehensible to ordinary mortals:
</p><ul>
<li>Make a pointer point "elsewhere" for a while
<pre><b>
	int* p = new int;
	p+=10;
	//</b> ... collector may run here ...<b>
	p-=10;
	*p = 10;	// </b>can we be sure that the int is still there?<b> 
</b></pre>
</li><li>Hide the pointer in an int
<pre><b>
	int* p = new int;
	int x = reinterpret_cast&lt;int&gt;(p);	// </b>non-portable<b>
	p=0;
	// </b>... collector may run here ...<b>
	p = reinterpret_cast&lt;int*&gt;(x);
	*p = 10;	// </b>can we be sure that the int is still there?<b>
</b></pre>
</li><li>There are many more and even nastier tricks
Think I/O, think "scattering the bits around in different words", ...
</li></ul>
There are legitimate reasons to disguise pointers
(e.g. the xor trick in exceptionally memory-constrained applications), but not as many as some programmers think.
<p>
A programmer can specify where there are no pointers to be found (e.g. in an image)
and what memory can't be reclaimed even if the collector can't find a pointer into it:
</p><pre><b>
	void declare_reachable(void* p);	// </b>the region of memory starting at p<b>
						// </b>(and allocated by some allocator<b>
						// </b>operation which remembers its size)<b>
						// </b>must not be collected<b>
	template&lt;class T&gt; T* undeclare_reachable(T* p);

	void declare_no_pointers(char* p, size_t n);	   // </b>p[0..n] holds no pointers<b>
	void undeclare_no_pointers(char* p, size_t n);
</b></pre>
A programmer can inquire which rules for pointer safety and reclamation is in force:
<pre><b>
	enum class pointer_safety {relaxed, preferred, strict };
	pointer_safety get_pointer_safety();
</b></pre>
3.7.4.3[4]: If a pointer value that is not a safely-derived pointer value is dereferenced or deallocated,
and the referenced complete object is of dynamic storage duration and has not previously been
declared reachable (20.7.13.7), the behavior is undefined.
<ul>
<li><b>relaxed</b>: safely-derived and not safely-derived pointers are treated equivalently;
like C and C++98, but that was not my intent - I wanted to allow GC if a user didn't keep a valid pointer
around for an object.
</li><li><b>preferred</b>: like relaxed;
but a garbage collector may be running as a leak detector and/or detector of dereferences of "bad pointers"
</li><li><b>strict</b>: safely-derived and not safely-derived pointers may be treated differently,
i.e. a garbage collector may be running and will ignore pointers that's not safely derived
</li></ul>
There is no standard way of saying which alternative you prefer.
Considered that a "quality of implementation" and a "programming environment" issue.
<p>

See also
</p><ul>
<li>the C++ draft 3.7.4.3
</li><li>the C++ draft 20.7.13.7
</li><li>Hans Boehm's
<a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/">GC page</a>
</li><li> Hans Boehm's
<a href="http://www.hpl.hp.com/personal/Hans_Boehm/gc/issues.html">Discussion of Conservative GC</a>
</li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2527.pdf">final proposal</a>
</li><li>Michael Spertus and Hans J. Boehm:
<a href="http://portal.acm.org/citation.cfm?doid=1542431.1542437">The Status of Garbage Collection in C++0X</a>.
ACM ISMM'09.
</li></ul>




<p>
</p><hr>
<h2 id="memory-model">Memory model</h2>
A memory model is an agreement between the machine architects and the compiler writers to ensure that
most programmers do not have to think about the details of modern computer hardware.
Without a memory model, few things related to threading, locking, and lock-free programming would make sense.
<p>
The key guarantee is: Two threads of execution can update and access separate memory locations
without interfering with each other.
But what is a ``memory location?'' 
A memory location is either an object of scalar type or a maximal sequence of adjacent bit-fields all having
non-zero width. 
For example, here <b>S</b> has exactly four separate memory locations:
</p><pre><b>
	struct S {
		char a;			// </b>location #1<b>
		int b:5,		// </b>location #2<b>
		int c:11,
		int :0,			//</b> note: :0 is "special"<b>
		int d:8;		// </b>location #3<b>
		struct {int ee:8;} e;	// </b>location #4<b>
	};
</b></pre>
Why is this important? Why isn't it obvious? Wasn't this always true?
The problem is that when several computations can genuinely run in parallel, that is several
(apparently) unrelated instructions can execute at the same time, the quirks of the memory hardware can get exposed.
In fact, in the absence of compiler support, issues of instruction and data pipelining and
details of cache use <i>will</i> be exposed in ways that are completely unmanageable to
the applications programmer.
This is true even if no two threads have been defined to share data!
Consider, two separately compiled ``threads:''
<pre><b>
	// </b>thread 1:<b>
	char c;
	c = 1;
	int x = c;

	// </b>thread 2:<b>
	char b;
	b = 1;
	int y = b;
</b></pre>
For greater realism, I could have used the separate compilation
(within each thread) to ensure that the compiler/optimizer wouldn't be able to eliminate memory
accesses and simply ignore <b>c</b> and <b>b</b> and directly initialize <b>x</b> and <b>y</b> with 1.
What are the possible values of <b>x</b> and <b>y</b>?
According to C++11 the only correct answer is the obvious one: 1 and 1.
The reason that's interesting is that if you take a conventional good pre-concurrency C or C++ compiler, the possible
answers are 0 and 0 (unlikely), 1 and 0, 0 and 1, and 1 and 1. This has been observed ``in the wild.''
How?
A linker might allocate <b>c</b> and <b>b</b> right next to each other (in the same word) -- nothing in the C or C++ 1990s standards
says otherwise.
In that, C++ resembles all languages not designed with real concurrent hardware in mind.
However, most modern processors cannot read or write a single character, it must read or write a whole word,
so the assignment to <b>c</b> really is ``read the word containing <b>c</b>, replace the <b>c</b> part, and write the word back again.''
Since the assignment to <b>b</b> is similar, there are plenty of opportunities for the two threads to clobber each other
even though the threads do not (according to their source text) share data!
<p>
So, C++11 guarantees that no such problems occur for ``separate memory locations.''
More precisely:
A memory location cannot be safely accessed by two threads without some form of locking
unless they are both read accesses. 
Note that different bitfields within a single word are not separate memory locations,
so don't share structs with bitfields among threads without some form of locking.
Apart from that caveat, the C++ memory model is simply ``as everyone would expect.''
</p><p>
However, it is not always easy to think straight about low-level concurrency issues.
Consider:
</p><pre><b>
	// start with x==0 and y==0

	if (x) y = 1;	// Thread 1 

	if (y) x = 1;	// Thread 2 
</b></pre>
<p>
Is there a problem here? More precisely, is there a data race? (No there isn't).
</p><p>
Fortunately, we have already adapted to modern times and every current C++ compiler (that I know of)
gives the one right answer and have done so for years.
They do so for most (but unfortunately not yet for all) tricky questions.
After all, C++ has been used for serious systems programming of concurrent systems ``forever.''
The standard should further improve things.
</p><p>
See also
</p><ul>
<li>Standard: 1.7 The C++ memory model [intro.memory] 
</li><li>Paul E. McKenney, Hans-J. Boehm, and Lawrence Crowl:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2556.html">C++ Data-Dependency Ordering: Atomics and Memory Model</a>.
N2556==08-0066.
</li><li>Hans-J. Boehm:
	<a href="http://www.hpl.hp.com/techreports/2009/HPL-2009-259html.html">Threads basics</a>,
	HPL technical report 2009-259.
	``what every programmer should know about memory model issues.''
</li><li>Hans-J. Boehm and Paul McKenney:
<a href="http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/user-faq.html">A slightly dated FAQ on C++ memory model issues</a>. 
</li></ul>



<p>
</p><hr>
<h2 id="std-threads">Threads</h2>
A thread is a representation of an execution/computation in a program.
In C++11, as in much modern computing, a thread can -- and usually does -- share an address space with
other threads.
In this, it differs from a process, which generally does not directly share data with other processes.
C++ have had a host of threads implementations for a variety of hardware and operating systems in the past,
what's new is a standard-library threads library, a standard thread ABI.
<p>
Many thick books and tens of thousands of papers have been writing about concurrency, parallelism, and threading,
this FAQ entry barely scratch the surface.
It is <i>hard</i> to think clearly about concurrency.
If you want to do concurrent programming, at least read a book.
Do not rely just on a manual, a standard, or an FAQ.
</p><p>
A thread is launched by constructing a std::thread with a function or a function object (incl. a
<a href="#lambda">lambda</a>):
</p><pre>	<b>
	#include&lt;thread&gt;

    	void f();

	struct F {
		void operator()();
	};

	int main()
	{
		std::thread t1{f};	// </b>f() executes in separate thread<b>
		std::thread t2{F()};	// </b>F()() executes in separate thread<b>
	}
</b></pre>
Unfortunately, this is unlikely to give any useful results -- whatever <b>f()</b> and <b>F()</b> might do.
The snag is that the program may terminate before or after <b>t1</b> executes <b>f()</b> and before or after <b>t2</b> executes <b>F()</b>.
We need to wait for the two tasks to complete:
<pre><b>
	int main()
	{
		std::thread t1{f};	// </b>f() executes in separate thread<b>
		std::thread t2{F()};	// </b>F()() executes in separate thread<b>

		t1.join();	// </b>wait for t1<b>
		t2.join();	// </b>wait for t2<b>
	}
</b></pre>
The <b>join()</b>s ensure that we don't terminate until the threads have completed.
To ``join'' means to ``wait for the thread to terminate.''
<p>
Typically, we'd like to pass some arguments to the task to be executed (I call something executed by a thread a task).
For example:
</p><pre><b>
    	void f(vector&lt;double&gt;&amp;);

	struct F {
		vector&lt;double&gt;&amp; v;
		F(vector&lt;double&gt;&amp; vv) :v{vv} { }
		void operator()();
	};

	int main()
	{
		std::thread t1{std::bind(f,some_vec)};	// </b>f(some_vec) executes in separate thread<b>
		std::thread t2{F(some_vec)};		// </b>F(some_vec)() executes in separate thread<b>

		t1.join();
		t2.join();
	}
</b></pre>
Basically, the standard library
<a href="#std-function">bind</a> makes a function object of its arguments.
<p>
In general, we'd also like to get a result back from an executed task.
With plain tasks, there is no notion of a return value; I recommend
<a href="#std-future">std::future</a> for that.
Alternative, we can pass an argument to a task telling it where to put its result:
For example:
</p><pre><b>
    	void f(vector&lt;double&gt;&amp;, double* res);	// </b>place result in res<b>

	struct F {
		vector&lt;double&gt;&amp; v;
		double* res;
		F(vector&lt;double&gt;&amp; vv, double* p) :v{vv}, res{p} { }
		void operator()();	// </b>place result in res<b>
	};

	int main()
	{
		double res1;
		double res2;

		std::thread t1{std::bind(f,some_vec,&amp;res1)};	// </b>f(some_vec,&amp;res1) executes in separate thread<b>
		std::thread t2{F(some_vec,&amp;res2)};		// </b>F(some_vec,&amp;res2)() executes in separate thread<b>

		t1.join();
		t2.join();
		
		std::cout &lt;&lt; res1 &lt;&lt; ' ' &lt;&lt; res2 &lt;&lt; '\n';
	}
</b></pre>
But what about errors? What if a task throws an exception?
If a task throws an exception and doesn't catch it itself <b>std::terminate()</b> is called.
That typically means that the program finishes. 
We usually try rather hard to avoid that.
A <a href="#std-future">std::future</a> can transmit an exception to the parent/calling thread;
that's one reason I like futures.
Otherwise, return some sort of error code.
<p>
When a <b>thread</b> goes out of scope the program is <b>terminate()</b>d unless its task has completed.
That's obviously to be avoided.
</p><p>
There is no way to request a <b>thread</b> to terminate (i.e. request that it exit as a soon as possible and as gracefully as possible) or to
force a thread to terminate (i.e. kill it).
We are left with the options of
</p><ul>
<li>designing our own cooperative ``interruption mechanism'' (with a piece of shared data that a caller thread can set for
a called thread to check (and quickly and gracefully exit when it is set)),
</li><li>``going native'' (using <b>thread::native_handle()</b> to gain access to the operating system's notion of a thread),
</li><li>kill the process (<b>std::quick_exit()</b>),
</li><li>kill the program (<b>std::terminate()</b>).
</li></ul>
This was all the committee could agree upon.
In particular, representatives from POSIX were vehemently against any form of ``thread cancellation''
however much C++'s model of resources rely on destructors.
There is no perfect solution for every systems and every possible application.
<p>
The basic problem with threads is data races;
that is, two threads running in a single address space can independently access an object
in ways that cause undefined results.
If one (or both) writes to the object and the other (or both) reads the object they have a
``race'' for who gets its operation(s) done first.
The results are not just undefined; they are usually completely unpredictable.
Consequently, C++11 provides some rules/guarantees for the programmer to avoid data races:
</p><ul>
<li> A C++ standard library function shall not directly or indirectly access objects accessible by threads
other than the current thread unless the objects are accessed directly or indirectly via the function's arguments,
including <b>this</b>.
</li><li> A C++ standard library function shall not directly or indirectly modify objects accessible by threads
other than the current thread unless the objects are accessed directly or indirectly via the function's nonconst
arguments, including <b>this</b>.
</li><li>C++ standard library implementations are required to avoid data
 races when different elements in the same sequence are modified 
concurrently.
</li></ul>
Concurrent access to a stream object, stream buffer object, or C Library stream
by multiple threads may result in a data race unless otherwise specified.
So don't share an output stream between two threads unless you somehow control the access to it.
<p>
You can
</p><ul>
<li> wait for a thread for <a href="#std-duration">a specified time</a>
</li><li>control access to some data <a href="#std-mutex">by mutual exclusion</a>
</li><li>control access to some data <a href="#std-lock">using locks</a>
</li><li>wait for an action of another task <a href="#std-condition">using a condition variable</a>
</li><li>return a value from a thread <a href="#std-future">through a future</a>
</li></ul>
<p>
See also
</p><ul>
<li>Standard: 30 Thread support library [thread]
</li><li>17.6.4.7 Data race avoidance [res.on.data.races]
</li><li>???
</li><li>H. Hinnant, L. Crowl, B. Dawes, A. Williams, J. Garland, et al.:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2320.html">Multi-threading Library for Standard C++ (Revision 1)</a>
N2497==08-0007
</li><li>H.-J. Boehm, L. Crowl:
<a href="">C++ object lifetime interactions with the threads API</a>
N2880==09-0070. 
</li><li>L. Crowl, P. Plauger, N. Stoughton:
<a href="">Thread Unsafe Standard Functions</a>
N2864==09-0054. 
</li><li>WG14:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2455.pdf">Thread Cancellation</a> N2455=070325.
</li></ul>




<p>
</p><hr>
<h2 id="std-mutex">Mutual exclusion</h2>
A <b>mutex</b> is a primitive object use for controlling access in a multi-threaded system.
The most basic use is
<pre><b>
	std::mutex m;
	int sh;	// </b>shared data<b>
	// </b>...<b>
	m.lock();
	// </b>manipulate shared data:<b>
	sh+=1;
	m.unlock();
</b></pre>
Only one thread at a time can be in the region of code between the <b>lock()</b> and the <b>unlock()</b> (often called a critical region).
If a second thread tries <b>m.lock()</b> while a first thread is executing in that region, that second thread
is blocked until the first executes the <b>m.unlock()</b>.
This is simple.
What is not simple is to use mutexes in a way that doesn't cause serious problems:
What if a thread ``forgets'' to <b>unlock()</b>?
What if a thread tries to <b>lock()</b> the same mutex twice?
What if a thread waits a very long time before doing an <b>unlock()</b>?
What if a thread need to <b>lock()</b> two mutexes to do its job?
The complete answers fill books.
Here (and in the <a href="#std-lock">Locks section</a>) are just the raw basics.
<p>
In addition to <b>lock()</b>, a <b>mutex</b> has a <b>try_lock()</b> operation which can be used to try to get into
the critical region without the risk of getting blocked:
</p><pre><b>
	std::mutex m;
	int sh;	// </b>shared data<b>
	// </b>...<b>
	if (m.try_lock()) {
		// </b>manipulate shared data:<b>
		sh+=1;
		m.unlock();
	else {
		// </b>maybe do something else<b>
	}

</b></pre>
<p>
A <b>recursive_mutex</b> is a <b>mutex</b> that can be acquired more than once by a thread:
</p><pre><b>
	std::recursive_mutex m;
	int sh;	// </b>shared data<b>
	// </b>...<b>
	void f(int i)
	{
		// </b>...<b>
		m.lock();
		// </b>manipulate shared data:<b>
		sh+=1;
		if (--i&gt;0) f(i);
		m.unlock();
		// </b>...<b>
	}
</b></pre>
Here, I have been blatant and let <b>f()</b> call itself.
Typically, the code is more subtle.
The recursive call will be indirect along the line of <b>f()</b> calls <b>g()</b> that calls <b>h()</b> that calls <b>f()</b>.
<p>
What if I need to acquire a <b>mutex</b> within the next ten seconds?
The <b>timed_mutex</b> class is offered for that.
Its operations are specialized versions of <b>try_lock()</b> with an associated time limit:
</p><pre><b>
	std::timed_mutex m;
	int sh;	// </b>shared data<b>
	// </b>...<b>
	if (m.try_lock_for(std::chrono::seconds(10))) {
		// </b>manipulate shared data:<b>
		sh+=1;
		m.unlock();
	}
	else {
		// </b>we didn't get the mutex; do something else<b>
	}
</b></pre>
The <b>try_lock_for()</b> takes a relative time, a <a href="#std-duration">duration</a> as its argument.
If instead you want to wait until a fixed point in time, a <a href="#std-duration">time_point</a>
you can use <b>try_lock_until()</b>:
<pre><b>
	std::timed_mutex m;
	int sh;	// </b>shared data<b>
	// </b>...<b>
	if (m.try_lock_until(midnight)) {
		// </b>manipulate shared data:<b>
		sh+=1;
		m.unlock();
	}
	else {
		// </b>we didn't get the mutex; do something else<b>
	}
</b></pre>
The <b>midnight</b> is a feeble joke: for a mechanism as low level as mutexes, the timescale is more
likely to be milliseconds than hours.
<p>
There is of course also a <b>recursive_timed_mutex</b>.
</p><p>
A mutex is considered a resource (as it is typically used to represent a real resource)
and must be visible to at least two threads to be useful.
Consequently, it cannot be copied or moved (you couldn't just make another copy of a hardware input register).
</p><p>
It can be surprisingly difficult to get the <b>lock()</b>s and <b>unlock()</b>s to match.
Think of complicated control structures, errors, and exceptions.
If you have a choice, use <a href="#std-lock">locks</a> to manage your mutexes;
that will save you and your users a lot of sleep.

</p><p>
See also
</p><ul>
<li>Standard: 30.4 Mutual exclusion [thread.mutex]
</li><li>H. Hinnant, L. Crowl, B. Dawes, A. Williams, J. Garland, et al.:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2320.html">Multi-threading Library for Standard C++ (Revision 1)</a>
</li><li>???
</li></ul>



<p>
</p><hr>
<h2 id="std-lock">Locks</h2>
A <b>lock</b> is an object that can hold a reference to a <b>mutex</b> and may <b>unlock()</b> the <b>mutex</b>
during the <b>lock</b>'s destruction
(such as when leaving block scope).
A <b>thread</b> may use a <b>lock</b> to aid in managing <b>mutex</b> ownership
in an exception safe manner.
In other words, a lock implements
<a href="http://www.stroustrup.com/bs_faq2.html#exceptions">Resource Acquisition Is Initialization</a>
for mutual exclusion.
For example:
<pre><b>
	std::mutex m;
	int sh;	// </b>shared data<b>
	// </b>...<b>
	void f()
	{
		// ...
		std::unique_lock lck(m);
		// </b>manipulate shared data:<b>
		sh+=1;
	}
</b></pre>
A lock can be moved (the purpose of a lock is to represent local ownership of a non-local resource),
but not copied (which copy would own the resource/<b>mutex</b>?).
<p>
This straightforward picture of a lock is clouded by <b>unique_lock</b> having facilities to do just about
everything a mutex can, but safer.
For example, we can use a lock to do try lock:
</p><pre><b>
	std::mutex m;
	int sh;	// </b>shared data<b>
	// </b>...<b>
	void f()
	{
		// ...
		std::unique_lock lck(m,std::defer_lock);	// </b>make a lock, but don't acquire the mutex<b>
		// </b>...<b>
		if (lck.try_lock()) {
			// </b>manipulate shared data:<b>
			sh+=1;
		}
		else {
			// </b>maybe do something else<b>
		}
	}
</b></pre>
Similarly, <b>unique_lock</b> supports <b>try_lock_for()</b> and try_lock_until().
What you get from using a lock rather than the mutex directly is exception handling and protection
against forgetting to <b>unlock()</b>.
In concurrent programming, we need all the help we can get.
<p>
What if we need two resources represented by two mutexes?
The naive way is to acquire the mutexes in order:
</p><pre><b>
	std::mutex m1;
	std::mutex m2;
	int sh1;	// </b>shared data<b>
	int sh2
	// </b>...<b>
	void f()
	{
		// ...
		std::unique_lock lck1(m1);
		std::unique_lock lck2(m2);
		// </b>manipulate shared data:<b>
		sh1+=sh2;
	}
</b></pre>
This has the potentially deadly flaw that some other thread could try to acquire <b>m1</b> and <b>m2</b> in the
opposite order so that each had one of the locks needed to proceed and would wait forever for the
second (that's called deadlock).
With many locks in a system, that's a real danger.
Consequently, the standard locks provide two functions for (safely) trying to acquire two or more locks:
<pre><b>
	void f()
	{
		// ...
		std::unique_lock lck1(m1,std::defer_lock);	// </b>make locks but don't yet try to acquire the mutexes<b>
		std::unique_lock lck2(m2,std::defer_lock);
		std::unique_lock lck3(m3,std::defer_lock);
		lock(lck1,lck2,lck3);
		// </b>manipulate shared data<b>
	}
</b></pre>
Obviously, the implementation of <b>lock()</b> has to be carefully crafted to avoid deadlock.
In essence, it will do the equivalent to careful use of <b>try_lock()</b>s.
If <b>lock()</b> fails to acquire all locks it will throw an exception.
Actually, <b>lock()</b> can take any argument with <b>lock()</b>, <b>try_lock()</b>, and <b>unlock()</b>
member functions (e.g. a <b>mutex</b>), so we
can't be specific about which exception <b>lock()</b> might throw; that depends on its arguments.
<p>
If you prefer to use <b>try_lock()</b>s yourself, there is an equivalent to <b>lock()</b> to help:
</p><pre><b>
	void f()
	{
		// ...
		std::unique_lock lck1(m1,std::defer_lock);	// </b>make locks but don't yet try to acquire the mutexes<b>
		std::unique_lock lck2(m2,std::defer_lock);
		std::unique_lock lck3(m3,std::defer_lock);
		int x;
		if ((x = try_lock(lck1,lck2,lck3))==-1) {	// </b>welcome to C land<b>
			// </b>manipulate shared data<b>
		}
		else {
			// </b>x holds the index of a mutex we could not acquire<b>
			// </b>e.g. if lck2.try_lock() failed x==1<b>
		}
	}
</b></pre>

<p>
See also
</p><ul>
<li>Standard: 30.4.3 Locks [thread.lock]
</li><li>???
</li></ul>




<p>
</p><hr>
<h2 id="std-condition">Condition variables</h2>
Condition variables provide synchronization primitives used to block a thread until notified by some other
thread that some condition is met or until a system time is reached.
<p>
Sorry, I have not had time to write this entry. Please come back later.

</p><p>
See also
</p><ul>
<li>Standard: 30.5 Condition variables [thread.condition]
</li><li>???
</li></ul>





<p>
</p><hr>
<h2 id="std-duration">Time utilities</h2>
We often want to time things or to do things dependent on timing.
For  example, the standard-library
<a href="#std-mutex">mutexes</a>
and
<a href="#std-lock">locks</a> provide the option for a 
<a href="#std-threads">thread</a> to wait for a period of time (a <b>duration</b>)
or to wait until a given point in time (a <b>time_point</b>).
<p>
If you want to know the current <b>time_point</b> you can call <b>now()</b> for one of three <b>clock</b>s:
<b>system_clock</b>, <b>monotonic_clock</b>, <b>high_resolution_clock</b>. For example:
</p><pre><b>
	monotonic_clock::time_point t = monotonic_clock::now();
	// </b>do something<b>
	monotonic_clock::duration d = monotonic_clock::now() - t;
	// </b>something took d time units<b>
</b></pre>
A <b>clock</b> returns a <b>time_point</b>,
and a <b>duration</b> is the difference of two <b>time_point</b>s from the same <b>clock</b>.
As usual, if you are not interested in details, <b>auto</b> is your friend:
<pre><b>
	auto t = monotonic_clock::now();
	// </b>do something<b>
	auto d = monotonic_clock::now() - t;
	// </b>something took d time units<b>
</b></pre>
<p>
The time facilities here are intended to efficiently support uses deep 
in the system;
they do not provide convenience facilities to help you maintain your 
social calendar.
In fact, the time facilities originated with the stringent needs for 
high-energy physics.
To be able to express all time scales (such as centuries and 
picoseconds), avoid confusion about units, typos, and rounding errors,
<b>duration</b>s and <b>time_point</b>s are
expressed using a compile-time rational number package.
A <b>duration</b> has two parts:
a numbers clock ``tick'' and something (a ``period'') that says what a tick means (is it a second or a millisecond?);
the period is part of a <b>durations</b> type.
This table from the standard header <b>&lt;ratio&gt;</b>,
defining the periods of the SI system (also known as MKS or metric system)
might give you an idea of the scope of use:
</p><pre><b>
	// </b>convenience SI typedefs:<b>
	typedef ratio&lt;1, 1000000000000000000000000&gt; yocto;  // </b>conditionally supported<b>
	typedef ratio&lt;1,    1000000000000000000000&gt; zepto;  // </b>conditionally supported<b>
	typedef ratio&lt;1,       1000000000000000000&gt; atto;
	typedef ratio&lt;1,          1000000000000000&gt; femto;
	typedef ratio&lt;1,             1000000000000&gt; pico;
	typedef ratio&lt;1,                1000000000&gt; nano;
	typedef ratio&lt;1,                   1000000&gt; micro;
	typedef ratio&lt;1,                      1000&gt; milli;
	typedef ratio&lt;1,                       100&gt; centi;
	typedef ratio&lt;1,                        10&gt; deci;
	typedef ratio&lt;                       10, 1&gt; deca;
	typedef ratio&lt;                      100, 1&gt; hecto;
	typedef ratio&lt;                     1000, 1&gt; kilo;
	typedef ratio&lt;                  1000000, 1&gt; mega;	
	typedef ratio&lt;               1000000000, 1&gt; giga;
	typedef ratio&lt;            1000000000000, 1&gt; tera;
	typedef ratio&lt;         1000000000000000, 1&gt; peta;
	typedef ratio&lt;      1000000000000000000, 1&gt; exa;	
	typedef ratio&lt;   1000000000000000000000, 1&gt; zetta;  // </b>conditionally supported<b>
	typedef ratio&lt;1000000000000000000000000, 1&gt; yotta;  // </b>conditionally supported<b>
</b></pre>
The compile time rational numbers provide the usual arithmetic
(<b>+</b>, <b>-</b>, <b>*</b>, and <b>/</b>) and comparison (==, !=, &lt;, &lt;=, &gt;, &gt;=) operators for whatever combinations 
<b>duration</b>s and <b>time_point</b>s makes sense (e.g. you can't add two time_points).
These operations are also checked for overflow and divide by zero.
Since this is a compile-time facility, don't worry about run-time performance.
In addition you can use ++, --, +=, -=, *=, and /= on <b>duration</b>s and <b>tp+=d</b> and <b>tp-=d</b> for a <b>time_point tp</b> and a <b>duration d</b>.
<p>
Here are some examples of values using standard <b>duration</b> types as defined in <b>&lt;chrono&gt;</b>:
</p><pre><b>
	microseconds mms = 12345;
	milliseconds ms = 123;
	seconds s = 10;
	minutes m = 30;
	hours h = 34;

	auto x = std::chrono::hours(3);			// </b>being explicit about namespaces<b>
	auto x = hours(2)+minutes(35)+seconds(9);	// </b>assuming suitable "using"<b>
</b></pre>
You cannot initialize a <b>duration</b> to a fraction.
For example, don't try 2.5 seconds; instead use 2500 milliseconds.
This is because a because a <b>duration</b> is interpreted as a number of ``ticks.''
Each tick represent on unit of the <b>duration</b>'s ``period,'' such as <b>milli</b> and <b>kilo</b> as defined above.
The default unit is <b>seconds</b>; that is, for a <b>duration</b> with a period of 1 a tick is interpreted as a second.
We can be explicit about the representation of a <b>duration</b>:
<pre><b>
	duration&lt;long&gt; d0 = 5;			// </b>seconds (by default)<b>
	duration&lt;long,kilo&gt; d1 = 99;		// </b>kiloseconds!<b>
	duration&lt;long,ratio&lt;1000,1&gt;&gt; d2 = 100;	// </b>d1 and d2 have the same type ("kilo" means "*1000")<b>
</b></pre>
If we actually want to do something with a <b>duration</b>, such as writing it out,
we have to give a unit, such as <b>minutes</b> or <b>microseconds</b>.
For example:
<pre><b>
	auto t = monotonic_clock::now();
	// </b>do something<b>
	nanoseconds d = monotonic_clock::now() - t;	// </b>we want the result in nanoseconds<b>
	cout &lt;&lt; "something took " &lt;&lt; d &lt;&lt; "nanoseconds\n";
</b></pre>
Alternatively, we could convert the <b>duration</b> to a floating point number (to get rounding):
<pre><b>
	auto t = monotonic_clock::now();
	// </b>do something<b>
	auto d = monotonic_clock::now() - t;
	cout &lt;&lt; "something took " &lt;&lt; duration_cast&lt;double&gt;(d).count() &lt;&lt; "seconds\n";
</b></pre>
The <b>count()</b> is the number of ``ticks.''
<p>
See also
</p><ul>
<li>Standard: 20.9 Time utilities [time]
</li><li>Howard E. Hinnant,
Walter E. Brown,
Jeff Garland,
and Marc Paterno:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm">A Foundation to Sleep On</a>.
N2661=08-0171.
Including ``A Brief History of Time'' (With apologies to Stephen Hawking).
</li></ul>




<p>
</p><hr>
<h2 id="std-atomics">Atomics</h2>
Sorry, I have not had time to write this entry. Please come back later.


<p>
See also
</p><ul>
<li>Standard: 29 Atomic operations library [atomics]
</li><li>???
</li></ul>



<p>
</p><hr>
<h2 id="std-future">std::future and std::promise</h2>
Concurrent programming can be <i>hard</i>,
especially if you try to be clever with <a href="#std-threads">threads</a>,
and <a href="#std-lock">locks</a>.
It is harder still if you must use <a href="#std-condition">condition variables</a>
or use <a href="#std-atomics">std-atomics</a> (for lock-free programming).
C++11 offers <b>future</b> and <b>promise</b> for returning a value from a task spawned on a separate thread
and <b>packaged_task</b> to help launch tasks.
The important point about <b>future</b> and <b>promise</b> is that they enable a transfer of a value between two tasks
without explicit use of a lock; ``the system'' implements the transfer efficiently.
The basic idea is simple: When a task wants to return a value to the <b>thread</b> that launched it,
it puts the value into a <b>promise</b>.
Somehow, the implementation makes that value appear in the <b>future</b> attached to the <b>promise</b>.
The caller (typically the launcher of the task) can then read the value.
For added simplicity, see <a href="#std-async">async()</a>. 
<p>
The standard provides three kinds of futures, <b>future</b> for most simple uses, and <b>shared_future</b> and <b>atomic_future</b> for some trickier cases.
Here, I'll just present <b>future</b> because it's the simplest and does all I need done.
If we have a <b>future&lt;X&gt;</b> called <b>f</b>, we can <b>get()</b> a value of type <b>X</b> from it:
</p><pre><b>
	X v = f.get();	// </b>if necessary wait for the value to get computed<b>
</b></pre>
If the value isn't there yet, our thread is blocked until it arrives.
If the value couldn't be computed, the result of <b>get()</b> might be to throw an exception
(from the system or transmitted from the task from which we were trying to <b>get()</b> the value.
<p>
We might not want to wait for a result, so we can ask the <b>future</b> if a result has arrived:
</p><pre><b>
	if (f.wait_for(0)) {	// </b>there is a value to get()<b>
		// </b>do something<b>
	}
	else {
		// </b>do something else<b>
	}
</b></pre> 
However, the main purpose of <b>future</b> is to provide that simple <b>get()</b>.
<p>
The main purpose of <b>promise</b> is to provide a simple ``put'' (curiously, called ``set'') to match <b>future</b>'s <b>get()</b>.
The names ``future'' and ``promise'' are historical; please don't blame me.
They are also a fertile source of puns.
</p><p>
If you have a <b>promise</b> and need to send a result of type <b>X</b> (back) to a <b>future</b>,
there are basically two things you can do: pass a value and pass an exception:
</p><pre><b>
	try {
		X res;
		// </b>compute a value for res<b>
		p.set_value(res);
	}
	catch (...) {	// </b>oops: couldn't compute res<b>
		p.set_exception(std::current_exception());
	}
</b></pre>
<p>
So far so good, but how do I get a matching <b>future</b>/<b>promise</b> pair,
one in my <b>thread</b> and one in some other <b>thread</b>?
Well, since <b>future</b>s and <b>promise</b>s can be moved (not copied) around there is a wide variety of possibilities.
The most obvious idea is for whoever wants a task done to create a thread and give the promise to it
while keeping the corresponding future as the place for the result.
Using <a href="#std-async">async()</a> is the most extreme/elegant variant of the latter technique.
</p><p>
The <b>packaged_task</b> type is provided to simplify launching a thread to execute a task.
In particular, it takes care of setting up a <b>future</b> connected to a <b>promise</b>
and to provides the wrapper code to put the return value or exception from the task into the <b>promise</b>.
For example:
</p><pre><b>
	double comp(vector&lt;double&gt;&amp; v)
	{
		// </b>package the tasks<b>:
		// </b>(the task here is the standard accumulate() for an array of doubles)<b>:
		packaged_task&lt;double(double*,double*,double)&gt; pt0{std::accumulate&lt;double*,double*,double&gt;};
		packaged_task&lt;double(double*,double*,double)&gt; pt1{std::accumulate&lt;double*,double*,double&gt;};

		auto f0 = pt0.get_future();	// </b>get hold of the futures<b>
		auto f1 = pt1.get_future();

		pt0(&amp;v[0],&amp;v[v.size()/2],0);	// </b>start the threads<b>
		pt1(&amp;v[v.size()/2],&amp;v[size()],0);
	
		return f0.get()+f1.get();	// </b>get the results<b>
	}
</b></pre>
<p>
See also
</p><ul>
<li>Standard: 30.6 Futures [futures]
</li><li>Anthony Williams:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2888.html">Moving Futures - Proposed Wording for UK comments 335, 336, 337 and 338</a>.
N2888==09-0078.
</li><li>Detlef Vollmann, Howard Hinnant, and Anthony Williams
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2627.html">An Asynchronous Future Value (revised)</a>
N2627=08-0137.
</li><li>Howard E. Hinnant:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2094.html">Multithreading API for C++0X - A Layered Approach</a>.
N2094=06-0164. The original proposal for a complete threading package..
</li></ul>



<p>
</p><hr>
<h2 id="std-async">std::async()</h2>
The <b>async()</b> simple task launcher function is the only facility in this FAQ that has not yet been voted
into the draft standard.
I expect it to be voted in in October after reconciling two slighty different proposals
(feel free to tell your local committee member to be sure to vote for it).
<p>
Here is an example of a way for the programmer to rise above the messy threads-plus-lock level of concurrent programming:
</p><pre><b>
	template&lt;class T, class V&gt; struct Accum  {	// </b>simple accumulator function object<b>
		T* b;
		T* e;
		V val;
		Accum(T* bb, T* ee, const V&amp; v) : b{bb}, e{ee}, val{vv} {}
		V operator() () { return std::accumulate(b,e,val); }
	};

	double comp(vector&lt;double&gt;&amp; v)
		// </b>spawn many tasks if v is large enough<b>
	{
		if (v.size()&lt;10000) return std::accumulate(v.begin(),v.end(),0.0);

		auto f0 {async(Accum{&amp;v[0],&amp;v[v.size()/4],0.0})};
		auto f1 {async(Accum{&amp;v[v.size()/4],&amp;v[v.size()/2],0.0})};
		auto f2 {async(Accum{&amp;v[v.size()/2],&amp;v[v.size()*3/4],0.0})};
		auto f3 {async(Accum{&amp;v[v.size()*3/4],&amp;v[v.size()],0.0})};

		return f0.get()+f1.get()+f2.get()+f3.get();
	}
</b></pre>
This is a very simple-minded use of concurrency (note the ``magic number''),
but note the absence of explicit <b>thread</b>s, <b>lock</b>s, buffers, etc.
The type of the <b>f</b>-variables are determined by the return type of the standard-library function
<b>async()</b> which is a
<a href="#std-future">future</a>.
If necessary, <b>get()</b> on a <b>future</b> waits for a
<a href="#std-threads">thread</a> to finish.
Here, it is <b>async()</b>'s job to spawn <b>thread</b>s as needed and the <b>future</b>'s job to <b>join()</b> the <b>thread</b>s appropriately.
``Simple'' is the most important aspect of the <b>async(</b>)/<b>future</b> design;
futures can also be used with threads in general,
but don't even <i>think</i> of using <b>async()</b> to launch tasks that do I/O, manipulates mutexes, or in other ways interact with other tasks.
The idea behind <b>async()</b> is the same as the idea behind the range-<b>for</b>
 statement:
Provide a simple way to handle the simplest, rather common, case and 
leave the more complex examples to the fully general mechanism.
<p>
An <b>async()</b> can be requested to launch in a new <b>thread</b>,
in any <b>thread</b> but the caller's,
or to launch in a different <b>thread</b> only if <b>async()</b> ``thinks'' that it is a good idea.
The latter is the simplest from the user's perspective and potentially the most efficient (for <i>simple</i> tasks(only)).

</p><p>
See also
</p><ul>
<li>Standard: ???
</li><li>Lawrence Crowl:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2889.html">An Asynchronous Call for C++</a>.
N2889 = 09-0079.
</li><li>Herb Sutter :
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2901.pdf">A simple async()</a>

 N2901 = 09-0091 .
</li></ul>





<p>
</p><hr>
<h2 id="abandoning">abandoning a process</h2>
Sorry, I have not had time to write this entry. Please come back later.
<ul>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2440.htm">Abandoning a process</a>
</li></ul>




<p>
</p><hr>
<h2 id="std-random">Random number generation</h2>
Random numbers are useful in many contexts, such as testing, games, simulation, and security.
The diversity of application areas is reflected in the wide selection of random number generators provided
by the standard library.
A random number generator consists of two parts an
<i>engine</i>
that produces a sequence of random or pseudo-random values and a
<i>distribution</i>
that maps those values in to a mathematical distribution in a range.
Examples of distributions are
<b>uniform_int_distribution</b> (where all integers produced are equally likely) and
<b>normal_distribution</b> (``the bell curve''); each for some specified range.
For example:
<pre><b>
	uniform_int_distribution&lt;int&gt; one_to_six {1,6};  // </b>distribution that maps to the ints 1..6<b>
	default_random_engine re {};                     // </b>the default engine<b>
</b></pre>
To get a random number, you call a distribution with an engine:
<pre><b>
	int x = one_to_six(re);	// </b>x becomes a value in [1:6]<b>
</b></pre>
Passing the engine in every call can be considered tedious, so we could 
bind that argument to get a function object that we can call without 
arguments:
<pre><b>
	auto dice {bind(one_to_six,re)};   // </b>make a generator<b>

	int x = dice();	// </b>roll the dice: x becomes a value in [1:6]<b>
</b></pre>
Thanks to its uncompromising attention to generality and performance one expert deemed the
standard-library random number component ``what every random number library wants to be when it grows up.''
However, it can hardly be deemed ``novice friendly.''
I have never found the random number interface to be a performance bottle neck, but I have never taught
novices (of any background) without needing a very simple random number generator.
This would be sufficient
<pre><b>
	int rand_int(int low, int high);	// </b>generate a random number from a uniform distribution in [low:high]<b>
</b></pre>
So, how could we get that?
We have to get something like
<b>dice()</b>
inside
<b>rand_int()</b>:
<pre><b>
	int rand_int(int low, int high)
	{
		static default_random_engine re {};
		using Dist = uniform_int_distribution&lt;int&gt;;
  		static Dist uid {};
  		return uid(re, Dist::param_type{low,high});
	}

</b></pre>
That definition is still ``expert level'' but the
<i>use</i>
of
<b>rand_int()</b>
manageable in the first week of a C++ course.
<p>
Just to show a non-trivial example, here is a program that generates and prints a normal distribution:
</p><pre> <b>
	default_random_engine re;   // </b>the default engine<b>
	normal_distribution&lt;int&gt; nd(31 /* </b>mean<b> */,8 /* </b>sigma<b> */);

	auto norm = std::bind(nd, re);

	vector&lt;int&gt; mn(64);

	int main()
	{
		for (int i = 0; i&lt;1200; ++i) ++mn[round(norm())]; // </b>generate<b>
	
		for (int i = 0; i&lt;mn.size(); ++i) {
			cout &lt;&lt; i &lt;&lt; '\t';
			for (int j=0; j&lt;mn[i]; ++j) cout &lt;&lt; '*';
			cout &lt;&lt; '\n';
		}
	}
</b></pre>
The result was:
<pre><b>
0	
1	
2	
3	
4	*
5	
6	
7	
8	
9	*
10	***
11	***
12	***
13	*****
14	*******
15	****
16	**********
17	***********
18	****************
19	*******************
20	*******************
21	**************************
22	**********************************
23	**********************************************
24	********************************************
25	*****************************************
26	*********************************************
27	*********************************************************
28	***************************************************
29	******************************************************************
30	**********************************************
31	*********************************************************************
32	**********************************************
33	*************************************************************
34	**************************************************************
35	***************************************
36	***********************************************
37	**********************************************
38	*********************************************
39	********************************
40	********************************************
41	***********************
42	**************************
43	******************************
44	*****************
45	*************
46	*********
47	********
48	*****
49	*****
50	****
51	***
52	***
53	**
54	*
55	*
56	
57	*
58	
59	
60	
61
62
63
</b></pre>
<p>
See also
</p><ul>
<li>Standard 26.5: Random number generation
</li></ul>



<p>
</p><hr>
<h2 id="std-regex">Regular expressions</h2>
<ul>
<li>28 Regular expressions library
</li></ul>
Sorry, I have not had time to write this entry. Please come back later.


<p>
See also
</p><ul>
<li>Standard: ???
</li><li>???
</li></ul>




<p>
</p><hr>
<h2 id="concepts">Concepts</h2>
<b>Warning: "concepts" did not make it into C++11 and a radical redesign is in progress</b>
<p>
"Concepts" is a mechanism for describing requirements on types, combinations of types, and combinations of types and integers.
It is particularly useful for getting early checking of uses of templates.
Conversely, it also helps early detection of errors in a template body.
Consider the standard library algorithm <b>fill</b>:
</p><pre>	template&lt;ForwardIterator Iter, class V&gt;          // types of types
		requires Assignable&lt;Iter::value_type,V&gt;  // relationships among argument types
	void fill(Iter first, Iter last, const V&amp; v);       // just a declaration, not definition


	fill(0, 9, 9.9);		// Iter is int; error: int is not a ForwardIterator
					//                     int does not have a prefix *
	fill(&amp;v[0], &amp;v[9], 9.9);	// Iter is int*; ok: int* is a ForwardIterator

</pre>
Note that we only declared <b>fill()</b>; we did not define it (provide its implementation).
On the other hand, we explicitly stated what <b>fill()</b> requires from its argument:
<ul>
<li>The arguments <b>first</b> and <b>last</b> must be of a type that is a <b>ForwardIterator</b>
(and they must be of the same type).
</li><li> The third argument <b>v</b> must be of a type that can be assigned to
the <b>ForwardIterator</b>'s <b>value_type</b>.
</li></ul>
We knew that, of course, having read the standard.
However, compilers do not read requirement documents, so we had to tell it in code
using the concepts <b>ForwardIterator</b> and <b>Assignable</b>.
The result is that errors in the use of <b>fill()</b> are caught immediately at the point of use
and that error messages are greatly improved.
The compiler now has the information about the programmers' intents to allow good checking and good diagnostics.
<p>
Concepts also help template implementers. Consider:
</p><pre>	template&lt;ForwardIterator Iter, class V&gt;
		requires Assignable&lt;Iter::value_type,V&gt;
	void fill(Iter first, Iter last, const V&amp; v)
	{
		while (first!=last) {
			*first = v;
			first=first+1;	// error: + not defined for ForwardIterator
					// (use ++first)
		}
	}
</pre>
This error is caught immediately, eliminating the need for much tedious testing
(though of course not all testing).
<p>
Being able to classify and distinguish different types of types, we can overload based on the kind of types passed.
For example
</p><pre>	// iterator-based standard sort (with concepts):
	template&lt;Random_access_iterator Iter&gt;
		requires Comparable&lt;Iter::value_type&gt;
	void sort(Iter first, Iter last); // use the usual implementation

	// container-based sort:
	template&lt;Container Cont&gt;
		requires Comparable&lt;Cont::value_type&gt;
	void sort(Cont&amp; c)
	{
		sort(c.begin(),c.end());    // simply call the iterator version
	}

	void f(vector&lt;int&gt;&amp; v)
	{
		sort(v.begin(), v.end());   // one way
		sort(v);                    // another way
		// ...
	}
</pre>
<p>
You can define your own concepts, but for starters the standard library provides a variety of useful concepts,
such as <b>ForwardIterator</b>, <b>Callable</b>, <b>LessThanComparable</b>, and <b>Regular</b>.
</p><p>
Note: the C++0x standard libraries were specified using concepts.
</p><p>
See also
</p><ul>
<li>the C++ draft 14.10 Concepts
</li><li>[N2617=08-0127] Douglas Gregor, Bjarne Stroustrup, James Widman, and Jeremy Siek:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2617.pdf">Proposed Wording for Concepts (Revision 5)</a> (Final proposal).
</li><li>Douglas Gregor, Jaakko Jarvi, Jeremy Siek, Bjarne Stroustrup, Gabriel Dos Reis, and Andrew Lumsdaine:
<a href="http://www.stroustrup.com/oopsla06.pdf">Concepts: Linguistic Support for Generic Programming in C++</a>.
OOPSLA'06, October 2006.
</li></ul>


<p>
</p><hr>
<h2 id="concept_maps">Concept maps</h2>
<p>
An <b>int*</b> is a <b>ForwardIterator</b>;
we said so when presenting <a href="#concepts">concepts</a>,
the standard has always said so,
and even the first version of the STL used pointers as iterators.
However, we also talked about <b>ForwardIterator</b>'s <b>value_type</b>.
But an <b>int*</b> does not have a member called <b>value_type</b>; in fact, it has no members.
So how can an <b>int*</b> be a <b>ForwardIterator</b>?
It is because we say it is.
Using a <b>concept_map</b>, we say that when a <b>T*</b> is used where a <b>ForwardIterator</b> is required,
we consider the <b>T</b> its <b>value_type</b>:
</p><pre>	template&lt;Value_type T&gt; 
	concept_map ForwardIterator&lt;T*&gt; {	  // T*'s value_type is T
		typedef T value_type;
	};
</pre>
A <b>concept_map</b> allows us to say how we want to see a type,
saving us from having to modify it or to wrap it into a new a type.
"Concept maps" is a very flexible and general mechanism for adapting independently developed software for common use.
<ul>
<li>the C++ draft 14.10.2 Concept maps
</li><li>[N2617=08-0127] Douglas Gregor, Bjarne Stroustrup, James Widman, and Jeremy Siek:
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2617.pdf">Proposed Wording for Concepts (Revision 5)</a> (Final proposal).
</li><li>Douglas Gregor, Jaakko Jarvi, Jeremy Siek, Bjarne Stroustrup, Gabriel Dos Reis, Andrew Lumsdaine:
<a href="http://www.stroustrup.com/oopsla06.pdf">Concepts: Linguistic Support for Generic Programming in C++</a>.
OOPSLA'06, October 2006.
</li></ul>



<p>
</p><hr>
<h2 id="axioms">Axioms</h2>
An axiom is a set of predicates specifying the semantics of a concept.
The primary use cases for axioms are external tools (e.g. not the common compiler actions), such as tools for domain-specific
optimizations (languages for specifying program transformations were a significant part of the motivation for axioms).
A secondary use is simply precise specification of semantics in the standard
(as is used in many parts of the standard library specification).
Axioms may also be useful for some optimizations (done by compilers and traditional optimizers), but compilers are
<i>not</i> required to take notice of user-supplied axioms; they work based on the semantics defined by the standard.
<p>
An axiom lists pairs of computations that may be considered equivalent.
Consider:
</p><pre>	concept Semigroup&lt;typename Op, typename T&gt; : CopyConstructible&lt;T&gt; {
		T operator()(Op, T, T);
		axiom Associativity(Op op, T x, T y, T z) {
			op(x, op(y, z)) &lt;=&gt; op(op(x, y), z);	// T's operator may be assumed to be associative
		}
	}

	concept Monoid&lt;typename Op, typename T&gt; : Semigroup&lt;Op, T&gt; {	// a monoid is a semigroup with an identity element
		T identity_element(Op);
		axiom Identity(Op op, T x) {
			op(x, identity_element(op)) &lt;=&gt; x;
			op(identity_element(op), x) &lt;=&gt; x;
		}
	}
</pre>
The <b>&lt;=&gt;</b> is the equivalence operator, which is used only in axioms.
Note that you cannot (in general) prove an axiom; we use axioms to state what we cannot prove,
but what a programmer can state to be an acceptable assumption.
Note that both sides of an equivalence statement may be illegal for some values, e.g. use of a NaN (not a number)
for a floating-point type: if both sides of an equivalence uses a NaN both are (obviously) invalid and equivalent
(independently of what the axiom says), but if only one side uses a NaN there may be opportunities for taking
advantage of the axiom.
<p>
An axiom is a sequence of equivalence statements (using <b>&lt;=&gt;</b>) and conditional statements
(of the form "if (something) then we may assume the following equivalence"):
</p><pre>	// in concept TotalOrder:
	axiom Transitivity(Op op, T x, T y, T z)
	{
		if (op(x, y) &amp;&amp; op(y, z)) op(x, z) &lt;=&gt; true;	// conditional equivalence 
	}
</pre>

See also
<ul>
<li>the C++ draft 14.9.1.4 Axioms
</li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/???.html">???</a>.
</li></ul>





<p>
</p><center>
<a href="http://www.morganstanley.com/">Morgan Stanley</a>
|
<a href="http://www.cs.columbia.edu/">Columbia University</a>
|
<a href="http://www.cse.tamu.edu/">Texas A&amp;M University</a>


</center>
<p>
</p><center>
<a href="http://www.stroustrup.com/index.html">home</a>
|
<a href="http://www.stroustrup.com/C++.html">C++</a>
|
<a href="http://www.stroustrup.com/bs_faq.html">FAQ</a>
|
<a href="http://www.stroustrup.com/bs_faq2.html">technical FAQ</a>
|
<a href="http://www.stroustrup.com/C++11FAQ.html">C++11 FAQ</a>
|
<a href="http://www.stroustrup.com/papers.html">publications</a>
|
<a href="http://www.stroustrup.com/4th.html">TC++PL</a>
|
<a href="http://www.stroustrup.com/Tour.html">Tour++</a>
|
<a href="http://www.stroustrup.com/programming.html">Programming</a>
|
<a href="http://www.stroustrup.com/dne.html">D&amp;E</a>
|
<a href="http://www.stroustrup.com/bio.html">bio</a>
|
<a href="http://www.stroustrup.com/interviews.html">interviews</a>
|
<a href="http://www.stroustrup.com/applications.html">applications</a>
|
<a href="http://www.stroustrup.com/glossary.html">glossary</a>
|
<a href="http://www.stroustrup.com/compilers.html">compilers</a>
</center>


</body></html>